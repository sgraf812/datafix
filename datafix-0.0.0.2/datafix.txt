-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fixing data-flow problems
--   
--   Fixing data-flow problems in expression trees. This should be useful
--   if you want to write optimizations for your favorite programming
--   language. See the Tutorial module for an introduction. After that, you
--   might want to take a look at the `examples/` folder in the
--   <a>repository</a>.
@package datafix
@version 0.0.0.2


-- | A uniform interface for ordered maps that can be used to model
--   monotone functions.
module Datafix.MonoMap

-- | Chooses an appropriate <a>MonoMap</a> for a given key type.
--   
--   <tt>MonoMap</tt>s should all be ordered maps, which feature efficient
--   variants of the <a>lookupLT</a> and <a>lookupMin</a> combinators. This
--   unifies <a>Data.Maybe</a>, <a>Data.IntMap.Strict</a>,
--   <a>Data.Map.Strict</a> and <a>Data.POMap.Strict</a> under a common
--   type class, for which instances can delegate to the most efficient
--   variant available.
--   
--   Because of <a>lookupLT</a>, this class lends itself well to
--   approximating monotone functions.
--   
--   The default implementation delegates to <a>POMap</a>, so when there is
--   no specially crafted map data-structure for your key type, all you
--   need to do is to make sure it satisfies <a>PartialOrd</a>. Then you
--   can do
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IntSet
--   
--   &gt;&gt;&gt; instance MonoMapKey IntSet
--   </pre>
--   
--   to make use of the default implementation.
class Foldable (MonoMap k) => MonoMapKey k where {
    type family MonoMap k = (r :: * -> *) | r -> k;
    type MonoMap k = POMap k;
}
empty :: MonoMapKey k => MonoMap k v
empty :: (MonoMapKey k, (MonoMap k v ~ POMap k v)) => MonoMap k v
singleton :: MonoMapKey k => k -> v -> MonoMap k v
singleton :: (MonoMapKey k, (MonoMap k v ~ POMap k v)) => k -> v -> MonoMap k v
insert :: MonoMapKey k => k -> v -> MonoMap k v -> MonoMap k v
insert :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> v -> MonoMap k v -> MonoMap k v
delete :: MonoMapKey k => k -> MonoMap k v -> MonoMap k v
delete :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> MonoMap k v
lookup :: MonoMapKey k => k -> MonoMap k v -> Maybe v
lookup :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> Maybe v

-- | Key point of this interface! Note that it returns a list of lower
--   bounds, to account for the <a>PartialOrd</a> case.
lookupLT :: MonoMapKey k => k -> MonoMap k v -> [(k, v)]

-- | Key point of this interface! Note that it returns a list of lower
--   bounds, to account for the <a>PartialOrd</a> case.
lookupLT :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> [(k, v)]
lookupMin :: MonoMapKey k => MonoMap k v -> [(k, v)]
lookupMin :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => MonoMap k v -> [(k, v)]
difference :: MonoMapKey k => MonoMap k a -> MonoMap k b -> MonoMap k a
difference :: (MonoMapKey k, MonoMap k a ~ POMap k a, MonoMap k b ~ POMap k b, PartialOrd k) => MonoMap k a -> MonoMap k b -> MonoMap k a
keys :: MonoMapKey k => MonoMap k a -> [k]
keys :: (MonoMapKey k, MonoMap k v ~ POMap k v) => MonoMap k v -> [k]
insertWith :: MonoMapKey k => (v -> v -> v) -> k -> v -> MonoMap k v -> MonoMap k v
insertWith :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (v -> v -> v) -> k -> v -> MonoMap k v -> MonoMap k v
insertLookupWithKey :: MonoMapKey k => (k -> v -> v -> v) -> k -> v -> MonoMap k v -> (Maybe v, MonoMap k v)
insertLookupWithKey :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (k -> v -> v -> v) -> k -> v -> MonoMap k v -> (Maybe v, MonoMap k v)
updateLookupWithKey :: MonoMapKey k => (k -> v -> Maybe v) -> k -> MonoMap k v -> (Maybe v, MonoMap k v)
updateLookupWithKey :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (k -> v -> Maybe v) -> k -> MonoMap k v -> (Maybe v, MonoMap k v)
alter :: MonoMapKey k => (Maybe v -> Maybe v) -> k -> MonoMap k v -> MonoMap k v
alter :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (Maybe v -> Maybe v) -> k -> MonoMap k v -> MonoMap k v
adjust :: MonoMapKey k => (v -> v) -> k -> MonoMap k v -> MonoMap k v
adjust :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (v -> v) -> k -> MonoMap k v -> MonoMap k v

-- | Delegates to <a>Maybe</a>.

-- | Delegates to <a>IntMap</a>.
instance Datafix.MonoMap.MonoMapKey ()
instance Datafix.MonoMap.MonoMapKey GHC.Types.Int


-- | Universally quantified constraints, until we have
--   -XQuantifiedConstraints.
module Datafix.Utils.Constraints
data Dict :: Constraint -> Type
[Dict] :: c => Dict c
newtype a (:-) b
Sub :: (a => Dict b) -> (:-) a b

-- | Given that <tt>a :- b</tt>, derive something that needs a context
--   <tt>b</tt>, using the context <tt>a</tt>
(\\) :: a => (b => r) -> (a :- b) -> r
infixl 1 \\

-- | A representation of the quantified constraint <tt>forall a. p a</tt>.
inst :: forall p a. Forall p :- p a
instance forall k (p :: k -> GHC.Types.Constraint). p (Datafix.Utils.Constraints.Skolem p) => Datafix.Utils.Constraints.Forall_ p


-- | Some type-level helpers for 'curry'/'uncurry'ing arbitrary function
--   types.
module Datafix.Utils.TypeLevel

-- | <tt>All p as</tt> ensures that the constraint <tt>p</tt> is satisfied
--   by all the <tt>types</tt> in <tt>as</tt>. (Types is between
--   scare-quotes here because the code is actually kind polymorphic)

-- | On Booleans

-- | On Lists

-- | Version of <tt>Foldr</tt> taking a defunctionalised argument so that
--   we can use partially applied functions.
data ConsMap0 :: (Function k l -> *) -> Function k (Function [l] [l] -> *) -> *
data ConsMap1 :: (Function k l -> *) -> k -> Function [l] [l] -> *

-- | <tt>Arrows [a1,..,an] r</tt> corresponds to <tt>a1 -&gt; .. -&gt; an
--   -&gt; r</tt>
type Arrows (as :: [*]) (r :: *) = Foldr (->) r as
arrowsAxiom :: Arrows (ParamTypes func) (ReturnType func) :~: func

-- | <tt>Products []</tt> corresponds to <tt>()</tt>, <tt>Products [a]</tt>
--   corresponds to <tt>a</tt>, <tt>Products [a1,..,an]</tt> corresponds to
--   <tt>(a1, (..,( an)..))</tt>.
--   
--   So, not quite a right fold, because we want to optimize for the empty,
--   singleton and pair case.

-- | <tt>IsBase t</tt> is <tt>'True</tt> whenever <tt>t</tt> is *not* a
--   function space.

-- | Using <tt>IsBase</tt> we can define notions of <tt>ParamTypes</tt> and
--   <tt>ReturnTypes</tt> which *reduce* under positive information
--   <tt>IsBase t ~ 'True</tt> even though the shape of <tt>t</tt> is not
--   formally exposed

-- | <tt>Currying as b</tt> witnesses the isomorphism between <tt>Arrows as
--   b</tt> and <tt>Products as -&gt; b</tt>. It is defined as a type class
--   rather than by recursion on a singleton for <tt>as</tt> so all of that
--   these conversions are inlined at compile time for concrete arguments.
class Currying as b
uncurrys :: Currying as b => Arrows as b -> Products as -> b
currys :: Currying as b => (Products as -> b) -> Arrows as b
data Function :: * -> * -> *
data Constant0 :: Function a (Function b a -> *) -> *
data Constant1 :: * -> Function b a -> *
instance Datafix.Utils.TypeLevel.Currying '[] b
instance Datafix.Utils.TypeLevel.Currying '[a] b
instance Datafix.Utils.TypeLevel.Currying (a2 : as) b => Datafix.Utils.TypeLevel.Currying (a1 : a2 : as) b


-- | Common definitions for defining data-flow problems, defining
--   infrastructure around the notion of <a>Domain</a>.
module Datafix.Common

-- | Data-flow problems denote <tt>Node</tt>s in the data-flow graph by
--   monotone transfer functions.
--   
--   This type alias alone carries no semantic meaning. However, it is
--   instructive to see some examples of how this alias reduces to a normal
--   form:
--   
--   <pre>
--   LiftedFunc Int m ~ m Int
--   LiftedFunc (Bool -&gt; Int) m ~ Bool -&gt; m Int
--   LiftedFunc (a -&gt; b -&gt; Int) m ~ a -&gt; b -&gt; m Int
--   LiftedFunc (a -&gt; b -&gt; c -&gt; Int) m ~ a -&gt; b -&gt; c -&gt; m Int
--   </pre>
--   
--   <tt>m</tt> will generally be an instance of <tt>MonadDependency</tt>
--   and the type alias effectively wraps <tt>m</tt> around
--   <tt>domain</tt>'s return type. The result is a function that produces
--   its return value while potentially triggering side-effects in
--   <tt>m</tt>, which amounts to depending on <a>LiftedFunc</a>s of other
--   <tt>Node</tt>s for the <tt>MonadDependency</tt> case.
type LiftedFunc domain m = Arrows (ParamTypes domain) (m (ReturnType domain))

-- | A function that checks points of some function with type
--   <tt>domain</tt> for changes. If this returns <a>True</a>, the point of
--   the function is assumed to have changed.
--   
--   An example is worth a thousand words, especially because of the
--   type-level hackery:
--   
--   <pre>
--   &gt;&gt;&gt; cd = (\a b -&gt; even a /= even b) :: ChangeDetector Int
--   </pre>
--   
--   This checks the parity for changes in the abstract domain of integers.
--   Integers of the same parity are considered unchanged.
--   
--   <pre>
--   &gt;&gt;&gt; cd 4 5
--   True
--   
--   &gt;&gt;&gt; cd 7 13
--   False
--   </pre>
--   
--   Now a (quite bogus) pointwise example:
--   
--   <pre>
--   &gt;&gt;&gt; cd = (\x fx gx -&gt; x + abs fx /= x + abs gx) :: ChangeDetector (Int -&gt; Int)
--   
--   &gt;&gt;&gt; cd 1 (-1) 1
--   False
--   
--   &gt;&gt;&gt; cd 15 1 2
--   True
--   
--   &gt;&gt;&gt; cd 13 35 (-35)
--   False
--   </pre>
--   
--   This would consider functions <tt>id</tt> and <tt>negate</tt>
--   unchanged, so the sequence <tt>iterate negate :: Int -&gt; Int</tt>
--   would be regarded immediately as convergent:
--   
--   <pre>
--   &gt;&gt;&gt; f x = iterate negate x !! 0
--   
--   &gt;&gt;&gt; let g x = iterate negate x !! 1
--   
--   &gt;&gt;&gt; cd 123 (f 123) (g 123)
--   False
--   </pre>
type ChangeDetector domain = Arrows (ParamTypes domain) (ReturnType domain -> ReturnType domain -> Bool)

-- | A <a>ChangeDetector</a> that delegates to the <a>Eq</a> instance of
--   the node values.
eqChangeDetector :: forall domain. Currying (ParamTypes domain) (ReturnType domain -> ReturnType domain -> Bool) => Eq (ReturnType domain) => ChangeDetector domain

-- | A <a>ChangeDetector</a> that always returns <a>True</a>.
--   
--   Use this when recomputing a node is cheaper than actually testing for
--   the change. Beware of cycles in the resulting dependency graph,
--   though!
alwaysChangeDetector :: forall domain. Currying (ParamTypes domain) (ReturnType domain -> ReturnType domain -> Bool) => ChangeDetector domain

-- | A monad with an associated <a>Domain</a>. This class exists mostly to
--   share the associated type-class between <tt>MonadDependency</tt> and
--   <tt>MonadDatafix</tt>.
--   
--   Also it implies that <tt>m</tt> satisfies <a>Datafixable</a>, which is
--   common enough
class (Monad m, Datafixable (Domain m)) => MonadDomain m where {
    type family Domain m :: *;
}

-- | A constraint synonym for constraints the <tt>domain</tt> has to
--   suffice.
--   
--   This is actually a lot less scary than you might think. Assuming we
--   got <a>quantified class constraints</a> instead of hackery from the
--   <a>@constraints@ package</a>, <tt>Datafixable</tt> is a specialized
--   version of this:
--   
--   <pre>
--   type Datafixable domain =
--     ( forall r. Currying (ParamTypes domain) r
--     , MonoMapKey (Products (ParamTypes domain))
--     , BoundedJoinSemiLattice (ReturnType domain)
--     )
--   </pre>
--   
--   Now, let's assume a concrete <tt>domain ~ String -&gt; Bool -&gt;
--   Int</tt>, so that <tt><a>ParamTypes</a> (String -&gt; Bool -&gt;
--   Int)</tt> expands to the type-level list <tt>'[String, Bool]</tt> and
--   <tt><a>Products</a> '[String, Bool]</tt> reduces to <tt>(String,
--   Bool)</tt>.
--   
--   Then this constraint makes sure we are able to
--   
--   <ol>
--   <li>Curry the domain of <tt>String -&gt; Bool -&gt; r</tt> for all
--   <tt>r</tt> to e.g. <tt>(String, Bool) -&gt; r</tt>. See
--   <a>Currying</a>. This constraint should always be discharged
--   automatically by the type-checker as soon as <a>ParamTypes</a> and
--   <tt>ReturnTypes</tt> reduce for the <a>Domain</a> argument, which
--   happens when the concrete <tt><tt>MonadDependency</tt> m</tt> is
--   known.</li>
--   <li>We want to use a <a>monotone</a> map of <tt>(String, Bool)</tt> to
--   <tt>Int</tt> (the <tt>ReturnType domain</tt>). This is ensured by the
--   <tt><a>MonoMapKey</a> (String, Bool)</tt> constraint.This constraint
--   has to be discharged manually, but should amount to a single line of
--   boiler-plate in most cases, see <a>MonoMapKey</a>.Note that the
--   monotonicity requirement means we have to pull non-monotone arguments
--   in <tt>Domain m</tt> into the <tt>Node</tt> portion of the
--   <tt>DataFlowProblem</tt>.</li>
--   <li>For fixed-point iteration to work at all, the values which we
--   iterate naturally have to be instances of
--   <a>BoundedJoinSemiLattice</a>. That type-class allows us to start
--   iteration from a most-optimistic <a>bottom</a> value and successively
--   iterate towards a conservative approximation using the '(/)'
--   operator.</li>
--   </ol>
type Datafixable domain = (Forall (Currying (ParamTypes domain)), MonoMapKey (Products (ParamTypes domain)), BoundedJoinSemiLattice (ReturnType domain))


-- | Primitives for describing a <a>data-flow problem</a> in a declarative
--   manner. This module requires you to manage assignment of <a>Node</a>s
--   in the data-flow graph to denotations by hand. If you're looking for a
--   safer approach suited for static analysis, have a look at
--   <a>Datafix.Denotational</a>.
--   
--   Import this module transitively through <a>Datafix</a> and get access
--   to <a>Datafix.Worklist</a> for functions that compute solutions to
--   your <a>DataFlowProblem</a>s.
module Datafix.Explicit

-- | This is the type we use to index nodes in the data-flow graph.
--   
--   The connection between syntactic things (e.g. <tt>Id</tt>s) and
--   <a>Node</a>s is made implicitly in code in analysis templates through
--   an appropriate allocation mechanism as in <tt>NodeAllocator</tt>.
newtype Node
Node :: Int -> Node
[unwrapNode] :: Node -> Int

-- | Models a data-flow problem, where each <a>Node</a> is mapped to its
--   denoting <a>LiftedFunc</a> and a means to detect when the iterated
--   transfer function reached a fixed-point through a
--   <a>ChangeDetector</a>.
data DataFlowProblem m
DFP :: !(Node -> LiftedFunc (Domain m) m) -> !(Node -> ChangeDetector (Domain m)) -> DataFlowProblem m

-- | A transfer function per each <a>Node</a> of the modeled data-flow
--   problem.
[dfpTransfer] :: DataFlowProblem m -> !(Node -> LiftedFunc (Domain m) m)

-- | A <a>ChangeDetector</a> for each <a>Node</a> of the modeled data-flow
--   problem. In the simplest case, this just delegates to an <a>Eq</a>
--   instance.
[dfpDetectChange] :: DataFlowProblem m -> !(Node -> ChangeDetector (Domain m))

-- | A monad with a single impure primitive <a>dependOn</a> that expresses
--   a dependency on a <a>Node</a> of a data-flow graph.
--   
--   The associated <a>Domain</a> type is the abstract domain in which we
--   denote <a>Node</a>s.
--   
--   Think of it like memoization on steroids. You can represent dynamic
--   programs with this quite easily:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferFib :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; Node -&gt; LiftedFunc Int m
--     transferFib (Node 0) = return 0
--     transferFib (Node 1) = return 1
--     transferFib (Node n) = (+) &lt;$&gt; dependOn @m (Node (n-1)) &lt;*&gt; dependOn @m (Node (n-2))
--     -- sparing the negative n error case
--   :}
--   </pre>
--   
--   We can construct a description of a <a>DataFlowProblem</a> with this
--   <tt>transferFib</tt> function:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     dataFlowProblem :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; DataFlowProblem m
--     dataFlowProblem = DFP transferFib (const (eqChangeDetector @(Domain m)))
--   :}
--   </pre>
--   
--   We regard the ordinary <tt>fib</tt> function a solution to the
--   recurrence modeled by <tt>transferFib</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib :: Int -&gt; Int
--     fib 0 = 0
--     fib 1 = 1
--     fib n = fib (n-1) + fib (n - 2)
--   :}
--   </pre>
--   
--   E.g., under the assumption of <tt>fib</tt> being total (which is true
--   on the domain of natural numbers), it computes the same results as the
--   least <i>fixed-point</i> of the series of iterations of the transfer
--   function <tt>transferFib</tt>.
--   
--   Ostensibly, the nth iteration of <tt>transferFib</tt> substitutes each
--   <tt>dependOn</tt> with <tt>transferFib</tt> repeatedly for n times and
--   finally substitutes all remaining <tt>dependOn</tt>s with a call to
--   <a>error</a>.
--   
--   Computing a solution by <i>fixed-point iteration</i> in a declarative
--   manner is the purpose of this library. There potentially are different
--   approaches to computing a solution, but in <a>Datafix.Worklist</a> we
--   offer an approach based on a worklist algorithm, trying to find a
--   smart order in which nodes in the data-flow graph are reiterated.
--   
--   The concrete MonadDependency depends on the solution algorithm, which
--   is in fact the reason why there is no satisfying data type in this
--   module: We are only concerned with <i>declaring</i> data-flow problems
--   here.
--   
--   The distinguishing feature of data-flow graphs is that they are not
--   necessarily acyclic (data-flow graphs of dynamic programs always
--   are!), but <a>under certain conditions</a> even have solutions when
--   there are cycles.
--   
--   Cycles occur commonly in data-flow problems of static analyses for
--   programming languages, introduced through loops or recursive
--   functions. Thus, this library mostly aims at making the life of
--   compiler writers easier.
class MonadDomain m => MonadDependency m

-- | Expresses a dependency on a node of the data-flow graph, thus
--   introducing a way of trackable recursion. That's similar to how you
--   would use <a>fix</a> to abstract over recursion.
dependOn :: MonadDependency m => Node -> LiftedFunc (Domain m) m
instance GHC.Show.Show Datafix.Explicit.Node
instance GHC.Classes.Ord Datafix.Explicit.Node
instance GHC.Classes.Eq Datafix.Explicit.Node


-- | Helpers for allocating <a>Node</a>s in an ergonomic manner, e.g.
--   taking care to get <a>mfix</a> right under the hood for allocation in
--   recursive bindings groups through the key primitive
--   <a>allocateNode</a>.
module Datafix.NodeAllocator

-- | A state monad wrapping a mapping from <a>Node</a> to some <tt>v</tt>
--   which we will instantiate to appropriate <tt>LiftedFunc</tt>s.
data NodeAllocator v a

-- | Allocates the next <a>Node</a>, which is greater than any nodes
--   requested before.
--   
--   The value stored at that node is the result of a <a>NodeAllocator</a>
--   computation which may already access the <a>Node</a> associated with
--   that value. This is important for the case of recursive let, where the
--   denotation of an expression depends on itself.
allocateNode :: (Node -> NodeAllocator v (a, v)) -> NodeAllocator v a

-- | Runs the allocator, beginning with an empty mapping.
runAllocator :: NodeAllocator v a -> (a, Array v)
instance GHC.Base.Monad (Datafix.NodeAllocator.NodeAllocator v)
instance GHC.Base.Applicative (Datafix.NodeAllocator.NodeAllocator v)
instance GHC.Base.Functor (Datafix.NodeAllocator.NodeAllocator v)


-- | Provides an alternative method (to
--   <tt>MonadDependency</tt>/<a>Datafix.Explicit</a>) of formulating
--   data-flow problems as a <a>Denotation</a> built in the context of
--   <a>MonadDatafix</a>. This offers better usability for defining static
--   analyses, as the problem of allocating nodes in the data-flow graph is
--   abstracted from the user.
module Datafix.Denotational

-- | Builds on an associated <a>DepM</a> that is a <a>MonadDomain</a> (like
--   any <tt>MonadDependency</tt>) by providing a way to track dependencies
--   without explicit <tt>Node</tt> management. Essentially, this allows to
--   specify a build plan for a <tt>DataFlowProblem</tt> through calls to
--   <a>datafix</a> in analogy to <tt>fix</tt> or <tt>mfix</tt>.
class (Monad m, MonadDomain (DepM m)) => MonadDatafix m where {
    type family DepM m :: * -> *;
}

-- | This is the closest we can get to an actual fixed-point combinator.
--   
--   We need to provide a <a>ChangeDetector</a> for detecting the
--   fixed-point as well as a function to be iterated. In addition to
--   returning a better approximation of itself in terms of itself, it can
--   return an arbitrary value of type <tt>a</tt>. Because the iterated
--   function might want to <a>datafix</a> additional times (think of
--   nested let bindings), the return values are wrapped in <tt>m</tt>.
--   
--   Finally, the arbitrary <tt>a</tt> value is returned, in analogy to
--   <tt>a</tt> in <tt><a>mfix</a> :: MonadFix m =&gt; (a -&gt; m a) -&gt;
--   m a</tt>.
datafix :: (MonadDatafix m, dom ~ Domain (DepM m)) => ChangeDetector dom -> (LiftedFunc dom (DepM m) -> m (a, LiftedFunc dom (DepM m))) -> m a

-- | Shorthand that partially applies <a>datafix</a> to an
--   <a>eqChangeDetector</a>.
datafixEq :: forall m dom a. MonadDatafix m => dom ~ Domain (DepM m) => Eq (ReturnType dom) => (LiftedFunc dom (DepM m) -> m (a, LiftedFunc dom (DepM m))) -> m a

-- | A denotation of some syntactic entity in a semantic <tt>domain</tt>,
--   built in a some <a>MonadDatafix</a> context.
type Denotation dom = forall m. (MonadDatafix m, dom ~ Domain (DepM m)) => m (LiftedFunc dom (DepM m))


-- | Builds a <a>DataFlowProblem</a> for a <a>Denotation</a>al formulation
--   in terms of <a>MonadDatafix</a>. Effectively reduces descriptions from
--   <a>Datafix.Denotational</a> to ones from <a>Datafix.Explicit</a>, so
--   that solvers such as <a>Datafix.Worklist</a> only have to provide an
--   interpreter for <a>MonadDependency</a>.
module Datafix.ProblemBuilder

-- | Constructs a build plan for a <a>DataFlowProblem</a> by tracking
--   allocation of <a>Node</a>s mapping to <a>ChangeDetector</a>s and
--   transfer functions.
data ProblemBuilder m a

-- | <tt>(root, max, dfp) = buildProblem builder</tt> executes the build
--   plan specified by <tt>builder</tt> and returns the resulting
--   <a>DataFlowProblem</a> <tt>dfp</tt>, as well as the <tt>root</tt>
--   <a>Node</a> denoting the transfer function returned by the
--   <a>ProblemBuilder</a> action and the <tt>max</tt>imum node of the
--   problem as a proof for its denseness.
buildProblem :: forall m. MonadDependency m => Denotation (Domain m) -> (Node, Node, DataFlowProblem m)
instance GHC.Base.Monad (Datafix.ProblemBuilder.ProblemBuilder m)
instance GHC.Base.Applicative (Datafix.ProblemBuilder.ProblemBuilder m)
instance GHC.Base.Functor (Datafix.ProblemBuilder.ProblemBuilder m)
instance Datafix.Explicit.MonadDependency m => Datafix.Denotational.MonadDatafix (Datafix.ProblemBuilder.ProblemBuilder m)


-- | Abstracts over the representation of the data-flow graph.
--   
--   The contents of this module are more or less internal to the
--   <a>Datafix.Worklist</a> implementation.
module Datafix.Worklist.Graph

-- | The data associated with each point in the transfer function of a
--   data-flow <tt>Node</tt>.
data PointInfo domain
PointInfo :: !(Maybe (ReturnType domain)) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !Int -> PointInfo domain

-- | The value at this point. Can be <a>Nothing</a> only when a loop was
--   detected.
[value] :: PointInfo domain -> !(Maybe (ReturnType domain))

-- | Points this point of the transfer function depends on.
[references] :: PointInfo domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | Points depending on this point.
[referrers] :: PointInfo domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | The number of times this point has been updated through calls to
--   <tt>updateNodeValue</tt>.
[iterations] :: PointInfo domain -> !Int

-- | The default <a>PointInfo</a>.
emptyPointInfo :: PointInfo domain

-- | Diff between two <a>IntArgsMonoSet</a>s.
data Diff a
Diff :: !(IntArgsMonoSet a) -> !(IntArgsMonoSet a) -> Diff a
[added] :: Diff a -> !(IntArgsMonoSet a)
[removed] :: Diff a -> !(IntArgsMonoSet a)

-- | Computes the diff between two <a>IntArgsMonoSet</a>s.
computeDiff :: MonoMapKey k => IntArgsMonoSet k -> IntArgsMonoSet k -> Diff k

-- | Abstracts over the concrete representation of the data-flow graph.
--   
--   There are two instances: The default <a>Ref</a> for sparse graphs
--   based on an <tt>IntMap</tt> and <a>Ref</a> for the dense case, storing
--   the <tt>Node</tt> mapping in a <a>IOVector</a>.
class GraphRef (ref :: * -> *)
updatePoint :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReturnType domain -> IntArgsMonoSet (Products (ParamTypes domain)) -> ReaderT (ref domain) IO (PointInfo domain)
lookup :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReaderT (ref domain) IO (Maybe (PointInfo domain))
lookupLT :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReaderT (ref domain) IO [(Products (ParamTypes domain), PointInfo domain)]
instance (GHC.Classes.Eq (Datafix.Utils.TypeLevel.ReturnType domain), GHC.Classes.Eq (Datafix.IntArgsMonoSet.IntArgsMonoSet (Datafix.Utils.TypeLevel.Products (Datafix.Utils.TypeLevel.ParamTypes domain)))) => GHC.Classes.Eq (Datafix.Worklist.Graph.PointInfo domain)
instance (GHC.Show.Show (Datafix.Utils.TypeLevel.ReturnType domain), GHC.Show.Show (Datafix.IntArgsMonoSet.IntArgsMonoSet (Datafix.Utils.TypeLevel.Products (Datafix.Utils.TypeLevel.ParamTypes domain)))) => GHC.Show.Show (Datafix.Worklist.Graph.PointInfo domain)


-- | Dense data-flow graph representation based on <a>IOVector</a>.
module Datafix.Worklist.Graph.Dense

-- | Reference to a dense data-flow graph representation.
data Ref domain

-- | Allocates a new dense graph <a>Ref</a>.
newRef :: MonoMapKey (Products (ParamTypes domain)) => Int -> IO (Ref domain)
instance Datafix.Worklist.Graph.GraphRef Datafix.Worklist.Graph.Dense.Ref


-- | Sparse data-flow graph representation based on <a>IntMap</a>.
module Datafix.Worklist.Graph.Sparse

-- | Reference to a sparse data-flow graph representation.
data Ref domain

-- | Allocates a new sparse graph <a>Ref</a>.
newRef :: IO (Ref domain)
instance Datafix.Worklist.Graph.GraphRef Datafix.Worklist.Graph.Sparse.Ref


-- | Internal module, does not follow the PVP. Breaking changes may happen
--   at any minor version.
module Datafix.Worklist.Internal

-- | The concrete <a>MonadDependency</a> for this worklist-based solver.
--   
--   This essentially tracks the current approximation of the solution to
--   the <a>DataFlowProblem</a> as mutable state while <a>solveProblem</a>
--   makes sure we will eventually halt with a conservative approximation.
newtype DependencyM graph domain a

-- | Why does this use <a>IO</a>? Actually, we only need <tt>ST</tt> here,
--   but that means we have to carry around the state thread in type
--   signatures.
--   
--   This ultimately leaks badly into the exported interface in
--   <a>solveProblem</a>: Since we can't have universally quantified
--   instance contexts (yet!), we can' write <tt>(forall s. Datafixable
--   domain =&gt; (forall s. DataFlowProblem (DependencyM s graph domain))
--   -&gt; ...</tt> and have to instead have the isomorphic <tt>(forall s
--   r. (Datafixable domain =&gt; r) -&gt; r) -&gt; (forall s.
--   DataFlowProblem (DependencyM s graph domain)) -&gt; ...</tt> and urge
--   all call sites to pass a meaningless <a>id</a> parameter.
--   
--   Also, this means more explicit type signatures as we have to make
--   clear to the type-checker that <tt>s</tt> is universally quantified in
--   everything that touches it, e.g.
--   <tt>Analyses.StrAnal.LetDn.buildProblem</tt> from the test suite.
--   
--   So, bottom line: We resort to <a>IO</a> and <a>unsafePerformIO</a> and
--   promise not to launch missiles. In particular, we don't export
--   <a>DM</a> and also there must never be an instance of <tt>MonadIO</tt>
--   for this.
DM :: (ReaderT (Env graph domain) IO a) -> DependencyM graph domain a

-- | The iteration state of 'DependencyM'/'solveProblem'.
data Env graph domain
Env :: !(DataFlowProblem (DependencyM graph domain)) -> !(IterationBound domain) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !(graph domain) -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain)))) -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain)))) -> Env graph domain

-- | Constant. The specification of the data-flow problem we ought to
--   solve.
[problem] :: Env graph domain -> !(DataFlowProblem (DependencyM graph domain))

-- | Constant. Whether to abort after a number of iterations or not.
[iterationBound] :: Env graph domain -> !(IterationBound domain)

-- | Contextual state. The set of points in the <tt>domain</tt> of
--   <a>Node</a>s currently in the call stack.
[callStack] :: Env graph domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | Constant ref to stateful graph. The data-flow graph, modeling
--   dependencies between data-flow <a>Node</a>s, or rather specific points
--   in the <tt>domain</tt> of each <a>Node</a>.
[graph] :: Env graph domain -> !(graph domain)

-- | Constant (but the the wrapped set is stateful). The set of points the
--   currently <a>recompute</a>d node references so far.
[referencedPoints] :: Env graph domain -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain))))

-- | Constant (but the the wrapped queue is stateful). Unstable nodes that
--   will be <a>recompute</a>d by the <a>work</a>list algorithm.
[unstable] :: Env graph domain -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain))))
initialEnv :: IntArgsMonoSet (Products (ParamTypes domain)) -> DataFlowProblem (DependencyM graph domain) -> IterationBound domain -> IO (graph domain) -> IO (Env graph domain)

-- | The <a>Domain</a> is extracted from a type parameter.

-- | This allows us to solve <tt>MonadDependency m =&gt; DataFlowProblem
--   m</tt> descriptions with <a>solveProblem</a>.

-- | Specifies the <i>density</i> of the problem, e.g. whether the domain
--   of <a>Node</a>s can be confined to a finite range, in which case
--   <a>solveProblem</a> tries to use a <a>Data.Vector</a> based graph
--   representation rather than one based on <a>Data.IntMap</a>.
data Density graph
[Sparse] :: Density Ref
[Dense] :: Node -> Density Ref

-- | A function that computes a sufficiently conservative approximation of
--   a point in the abstract domain for when the solution algorithm decides
--   to have iterated the node often enough.
--   
--   When <tt>domain</tt> is a 'BoundedMeetSemilattice'/'BoundedLattice',
--   the simplest abortion function would be to constantly return
--   <a>top</a>.
--   
--   As is the case for <a>LiftedFunc</a> and <a>ChangeDetector</a>, this
--   carries little semantic meaning if viewed in isolation, so here are a
--   few examples for how the synonym expands:
--   
--   <pre>
--   AbortionFunction Int ~ Int -&gt; Int
--   AbortionFunction (String -&gt; Int) ~ String -&gt; Int -&gt; Int
--   AbortionFunction (a -&gt; b -&gt; c -&gt; PowerSet) ~ a -&gt; b -&gt; c -&gt; PowerSet -&gt; PowerSet
--   </pre>
--   
--   E.g., the current value of the point is passed in (the tuple <tt>(a,
--   b, c, PowerSet)</tt>) and the function returns an appropriate
--   conservative approximation in that point.
type AbortionFunction domain = Arrows (ParamTypes domain) (ReturnType domain -> ReturnType domain)

-- | Aborts iteration of a value by <a>const</a>antly returning the
--   <a>top</a> element of the assumed <a>BoundedMeetSemiLattice</a> of the
--   <a>ReturnType</a>.
abortWithTop :: forall domain. Currying (ParamTypes domain) (ReturnType domain -> ReturnType domain) => BoundedMeetSemiLattice (ReturnType domain) => AbortionFunction domain

-- | Expresses that iteration should or shouldn't stop after a point has
--   been iterated a finite number of times.
data IterationBound domain

-- | Will keep on iterating until a precise, yet conservative approximation
--   has been reached. Make sure that your <tt>domain</tt> satisfies the
--   <a>ascending chain condition</a>, e.g. that fixed-point iteration
--   always comes to a halt!
NeverAbort :: IterationBound domain

-- | For when your <tt>domain</tt> doesn't satisfy the ascending chain
--   condition or when you are sensitive about solution performance.
--   
--   The <a>Int</a>eger determines the maximum number of iterations of a
--   single point of a <a>Node</a> (with which an entire function with many
--   points may be associated) before iteration aborts in that point by
--   calling the supplied <a>AbortionFunction</a>. The responsibility of
--   the <a>AbortionFunction</a> is to find a sufficiently conservative
--   approximation for the current value at that point.
--   
--   When your <a>ReturnType</a> is an instance of
--   <a>BoundedMeetSemiLattice</a>, <a>abortWithTop</a> might be a
--   worthwhile option. A more sophisticated solution would trim the
--   current value to a certain cut-off depth, depending on the first
--   parameter, instead.
AbortAfter :: Int -> (AbortionFunction domain) -> IterationBound domain
zoomIORef :: State s a -> ReaderT (IORef s) IO a
zoomReferencedPoints :: State (IntArgsMonoSet (Products (ParamTypes domain))) a -> ReaderT (Env graph domain) IO a
zoomUnstable :: State (IntArgsMonoSet (Products (ParamTypes domain))) a -> ReaderT (Env graph domain) IO a
enqueueUnstable :: k ~ Products (ParamTypes domain) => MonoMapKey k => Int -> k -> ReaderT (Env graph domain) IO ()
deleteUnstable :: k ~ Products (ParamTypes domain) => MonoMapKey k => Int -> k -> ReaderT (Env graph domain) IO ()
highestPriorityUnstableNode :: k ~ Products (ParamTypes domain) => MonoMapKey k => ReaderT (Env graph domain) IO (Maybe (Int, k))
withCall :: Datafixable domain => Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO a -> ReaderT (Env graph domain) IO a

-- | The first of the two major functions of this module.
--   
--   <tt>recompute node args</tt> iterates the value of the passed
--   <tt>node</tt> at the point <tt>args</tt> by invoking its transfer
--   function. It does so in a way that respects the <a>IterationBound</a>.
--   
--   This function is not exported, and is only called by <a>work</a> and
--   <a>dependOn</a>, for when the iteration strategy decides that the
--   <tt>node</tt> needs to be (and can be) re-iterated. It performs
--   tracking of which <a>Node</a>s the transfer function depended on, do
--   that the worklist algorithm can do its magic.
recompute :: forall domain graph dom cod depm. dom ~ ParamTypes domain => cod ~ ReturnType domain => depm ~ DependencyM graph domain => GraphRef graph => Datafixable domain => Int -> Products dom -> ReaderT (Env graph domain) IO cod
dependOn :: forall domain graph depm. depm ~ DependencyM graph domain => Datafixable domain => GraphRef graph => Node -> LiftedFunc domain depm

-- | Compute an optimistic approximation for a point of a given node that
--   is as precise as possible, given the other points of that node we
--   already computed.
--   
--   E.g., it is always valid to return <a>bottom</a> from this, but in
--   many cases we can be more precise since we possibly have computed
--   points for the node that are lower bounds to the current point.
optimisticApproximation :: GraphRef graph => Datafixable domain => Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | scheme 1 (see
--   <a>https://github.com/sgraf812/journal/blob/09f0521dbdf53e7e5777501fc868bb507f5ceb1a/datafix.md.html#how-an-algorithm-that-can-do-3-looks-like)</a>.
--   
--   Let the worklist algorithm figure things out.
scheme1 :: GraphRef graph => Datafixable domain => Maybe (ReturnType domain) -> Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | scheme 2 (see
--   <a>https://github.com/sgraf812/journal/blob/09f0521dbdf53e7e5777501fc868bb507f5ceb1a/datafix.md.html#how-an-algorithm-that-can-do-3-looks-like)</a>.
--   
--   Descend into &lt;math&gt; nodes when there is no cycle to discover the
--   set of reachable nodes as quick as possible. Do *not* descend into
--   unstable, non-(bot) nodes.
scheme2 :: GraphRef graph => Datafixable domain => Maybe (ReturnType domain) -> Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | As long as the supplied <a>Maybe</a> expression returns "Just _", the
--   loop body will be called and passed the value contained in the
--   <a>Just</a>. Results are discarded.
--   
--   Taken from <a>whileJust_</a>.
whileJust_ :: Monad m => m (Maybe a) -> (a -> m b) -> m ()

-- | Defined as 'work = whileJust_ highestPriorityUnstableNode (uncurry
--   recompute)'.
--   
--   Tries to dequeue the <a>highestPriorityUnstableNode</a> and
--   <a>recompute</a>s the value of one of its <a>unstable</a> points,
--   until the worklist is empty, indicating that a fixed-point has been
--   reached.
work :: GraphRef graph => Datafixable domain => ReaderT (Env graph domain) IO ()

-- | Computes a solution to the described <a>DataFlowProblem</a> by
--   iterating transfer functions until a fixed-point is reached.
--   
--   It does do by employing a worklist algorithm, iterating unstable
--   <a>Node</a>s only. <a>Node</a>s become unstable when the point of
--   another <a>Node</a> their transfer function <a>dependOn</a>ed changed.
--   
--   The sole initially unstable <a>Node</a> is the last parameter, and if
--   your <tt>domain</tt> is function-valued (so the returned <a>Arrows</a>
--   expands to a function), then any further parameters specify the exact
--   point in the <a>Node</a>s transfer function you are interested in.
--   
--   If your problem only has finitely many different <a>Node</a>s ,
--   consider using the <tt>ProblemBuilder</tt> API (e.g. <tt>datafix</tt>
--   + <tt>evalDenotation</tt>) for a higher-level API that let's you
--   forget about <a>Node</a>s and instead let's you focus on building more
--   complex data-flow frameworks.
solveProblem :: forall domain graph. GraphRef graph => Datafixable domain => DataFlowProblem (DependencyM graph domain) -> Density graph -> IterationBound domain -> Node -> domain
instance GHC.Base.Monad (Datafix.Worklist.Internal.DependencyM graph domain)
instance GHC.Base.Applicative (Datafix.Worklist.Internal.DependencyM graph domain)
instance GHC.Base.Functor (Datafix.Worklist.Internal.DependencyM graph domain)
instance Datafix.Common.Datafixable domain => Datafix.Common.MonadDomain (Datafix.Worklist.Internal.DependencyM graph domain)
instance (Datafix.Common.Datafixable domain, Datafix.Worklist.Graph.GraphRef graph) => Datafix.Explicit.MonadDependency (Datafix.Worklist.Internal.DependencyM graph domain)


-- | Bridges the <a>Datafix.Worklist</a> solver for
--   <tt>DataFlowProblem</tt>s (<a>solveProblem</a>) with the
--   <a>Datafix.Denotational</a> approach, using <a>MonadDatafix</a> to
--   describe a <a>Denotation</a>.
module Datafix.Worklist.Denotational

-- | <tt>evalDenotation denot ib</tt> returns a value in <tt>domain</tt>
--   that is described by the denotation <tt>denot</tt>.
--   
--   It does so by building up the <tt>DataFlowProblem</tt> corresponding
--   to <tt>denot</tt> and solving the resulting problem with
--   <a>solveProblem</a>, the documentation of which describes in detail
--   how to arrive at a stable denotation and what the
--   <a>IterationBound</a> <tt>ib</tt> is for.
evalDenotation :: Datafixable domain => Denotation domain -> IterationBound domain -> domain


-- | This module provides the <a>solveProblem</a> function, which solves
--   the description of a <a>DataFlowProblem</a> by employing a worklist
--   algorithm. There's also an interpreter for <tt>Denotation</tt>al
--   problems in the form of <a>evalDenotation</a>.
module Datafix.Worklist

-- | The concrete <a>MonadDependency</a> for this worklist-based solver.
--   
--   This essentially tracks the current approximation of the solution to
--   the <a>DataFlowProblem</a> as mutable state while <a>solveProblem</a>
--   makes sure we will eventually halt with a conservative approximation.
data DependencyM graph domain a

-- | Specifies the <i>density</i> of the problem, e.g. whether the domain
--   of <a>Node</a>s can be confined to a finite range, in which case
--   <a>solveProblem</a> tries to use a <a>Data.Vector</a> based graph
--   representation rather than one based on <a>Data.IntMap</a>.
data Density graph
[Sparse] :: Density Ref
[Dense] :: Node -> Density Ref

-- | Expresses that iteration should or shouldn't stop after a point has
--   been iterated a finite number of times.
data IterationBound domain

-- | Will keep on iterating until a precise, yet conservative approximation
--   has been reached. Make sure that your <tt>domain</tt> satisfies the
--   <a>ascending chain condition</a>, e.g. that fixed-point iteration
--   always comes to a halt!
NeverAbort :: IterationBound domain

-- | For when your <tt>domain</tt> doesn't satisfy the ascending chain
--   condition or when you are sensitive about solution performance.
--   
--   The <a>Int</a>eger determines the maximum number of iterations of a
--   single point of a <a>Node</a> (with which an entire function with many
--   points may be associated) before iteration aborts in that point by
--   calling the supplied <a>AbortionFunction</a>. The responsibility of
--   the <a>AbortionFunction</a> is to find a sufficiently conservative
--   approximation for the current value at that point.
--   
--   When your <a>ReturnType</a> is an instance of
--   <a>BoundedMeetSemiLattice</a>, <a>abortWithTop</a> might be a
--   worthwhile option. A more sophisticated solution would trim the
--   current value to a certain cut-off depth, depending on the first
--   parameter, instead.
AbortAfter :: Int -> (AbortionFunction domain) -> IterationBound domain

-- | Computes a solution to the described <a>DataFlowProblem</a> by
--   iterating transfer functions until a fixed-point is reached.
--   
--   It does do by employing a worklist algorithm, iterating unstable
--   <a>Node</a>s only. <a>Node</a>s become unstable when the point of
--   another <a>Node</a> their transfer function <a>dependOn</a>ed changed.
--   
--   The sole initially unstable <a>Node</a> is the last parameter, and if
--   your <tt>domain</tt> is function-valued (so the returned <a>Arrows</a>
--   expands to a function), then any further parameters specify the exact
--   point in the <a>Node</a>s transfer function you are interested in.
--   
--   If your problem only has finitely many different <a>Node</a>s ,
--   consider using the <tt>ProblemBuilder</tt> API (e.g. <tt>datafix</tt>
--   + <tt>evalDenotation</tt>) for a higher-level API that let's you
--   forget about <a>Node</a>s and instead let's you focus on building more
--   complex data-flow frameworks.
solveProblem :: forall domain graph. GraphRef graph => Datafixable domain => DataFlowProblem (DependencyM graph domain) -> Density graph -> IterationBound domain -> Node -> domain

-- | <tt>evalDenotation denot ib</tt> returns a value in <tt>domain</tt>
--   that is described by the denotation <tt>denot</tt>.
--   
--   It does so by building up the <tt>DataFlowProblem</tt> corresponding
--   to <tt>denot</tt> and solving the resulting problem with
--   <a>solveProblem</a>, the documentation of which describes in detail
--   how to arrive at a stable denotation and what the
--   <a>IterationBound</a> <tt>ib</tt> is for.
evalDenotation :: Datafixable domain => Denotation domain -> IterationBound domain -> domain


-- | This is the top-level, import-all, kitchen sink module.
--   
--   Look at <a>Datafix.Tutorial</a> for a tour guided by use cases.
module Datafix


-- | <h1>What is This?</h1>
--   
--   The purpose of <tt>datafix</tt> is to separate declaring <a>data-flow
--   problems</a> from computing their solutions by <a>fixed-point
--   iteration</a>.
--   
--   The need for this library arose when I was combining two analyses
--   within GHC for my master's thesis. I recently <a>held a talk</a> on
--   that topic, feel free to click through if you want to know the
--   details.
--   
--   You can think of data-flow problems as problems that are solvable by
--   <a>dynamic programming</a> or <a>memoization</a>, except that the
--   dependency graph of data-flow problems doesn't need to be acyclic.
--   
--   Data-flow problems are declared with the primitives in
--   <tt><a>Datafix.Description</a></tt> and solved by
--   <tt>Datafix.Worklist.<a>solveProblem</a></tt>.
--   
--   With that out of the way, let's set in place the GHCi environment of
--   our examples:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XScopedTypeVariables
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; :set -XTypeFamilies
--   
--   &gt;&gt;&gt; import Datafix
--   
--   &gt;&gt;&gt; import Data.Proxy (Proxy (..))
--   
--   &gt;&gt;&gt; import Algebra.Lattice (JoinSemiLattice (..), BoundedJoinSemiLattice (..))
--   
--   &gt;&gt;&gt; import Numeric.Natural
--   </pre>
--   
--   <h1>Use Case: Solving Recurrences</h1>
--   
--   Let's start out by computing the fibonacci series:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib :: Natural -&gt; Natural
--     fib 0 = 0
--     fib 1 = 1
--     fib n = fib (n-1) + fib (n-2)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fib 3
--   2
--   
--   &gt;&gt;&gt; fib 10
--   55
--   </pre>
--   
--   Bring your rabbits to the vet while you can still count them...
--   
--   Anyway, the fibonacci series is a typical problem exhibiting
--   <i>overlapping subproblems</i>. As a result, our <tt>fib</tt> function
--   from above scales badly in the size of its input argument <tt>n</tt>.
--   Because we repeatedly recompute solutions, the time complexity of our
--   above function is in &lt;math&gt;!
--   
--   We can do better by using <i>dynamic programming</i> or
--   <i>memoization</i> to keep a cache of already computed sub-problems,
--   which helps computing the &lt;math&gt;th item in &lt;math&gt; time and
--   space:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib2 :: Natural -&gt; Natural
--     fib2 n = fibs !! fromIntegral n
--       where
--         fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fib2 3
--   2
--   
--   &gt;&gt;&gt; fib2 10
--   55
--   </pre>
--   
--   That's one of Haskell's pet issues: Expressing dynamic programs as
--   lists through laziness.
--   
--   As promised in the previous section, we can do the same using
--   <tt>datafix</tt>. First, we need to declare a <i>transfer function</i>
--   that makes the data dependencies for the recursive case explicit, as
--   if we were using <a>fix</a> to eliminate the recursion:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferFib
--       :: forall m
--        . (MonadDependency m, Domain m ~ Natural)
--       =&gt; Node
--       -&gt; LiftedFunc Natural m
--     transferFib (Node 0) = return 0
--     transferFib (Node 1) = return 1
--     transferFib (Node n) = do
--       a &lt;- dependOn @m (Node (n-1))
--       b &lt;- dependOn @m (Node (n-2))
--       return (a + b)
--   :}
--   </pre>
--   
--   <a>MonadDependency</a> contains a single primitive <a>dependOn</a> for
--   that purpose.
--   
--   Every point of the fibonacci series is modeled as a seperate
--   <a>Node</a> of the data-flow graph. By looking at the definition of
--   <a>LiftedFunc</a>, we can see that <tt>LiftedFunc Natural m ~ m
--   Natural</tt>, so for our simple <tt>Natural</tt> <a>Domain</a>, the
--   transfer function is specified directly in <a>MonadDependency</a>.
--   
--   Note that indeed we eliminated explicit recursion in
--   <tt>transferFib</tt>. This allows the solution algorithm to track and
--   discover dependencies of the transfer function as it is executed!
--   
--   With our transfer function (which denotes data-flow nodes in the
--   semantics of <tt>Natural</tt>s) in place, we can construct a
--   <a>DataFlowProblem</a>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fibDfp :: forall m . (MonadDependency m, Domain m ~ Natural) =&gt; DataFlowProblem m
--     fibDfp = DFP transferFib (const (eqChangeDetector @(Domain m)))
--   :}
--   </pre>
--   
--   The <a>eqChangeDetector</a> is important for cyclic dependency graphs
--   and makes sure we detect when a fixed-point has been reached.
--   
--   That's it for describing the data-flow problem of fibonacci numbers.
--   We can ask <tt>Datafix.Worklist.<a>solveProblem</a></tt> for a
--   solution in a minute.
--   
--   The <a>solveProblem</a> solver demands an instance of
--   <tt>BoundedJoinSemiLattice</tt> on the <a>Domain</a> for when the
--   data-flow graph is cyclic. We conveniently delegate to the total
--   <tt>Ord</tt> instance for <a>Natural</a>, knowing that its semantic
--   interpretation is irrelevant to us:
--   
--   <pre>
--   &gt;&gt;&gt; instance JoinSemiLattice Natural where (\/) = max
--   
--   &gt;&gt;&gt; instance BoundedJoinSemiLattice Natural where bottom = 0
--   </pre>
--   
--   And now the final incantation of the solver:
--   
--   <pre>
--   &gt;&gt;&gt; solveProblem fibDfp Sparse NeverAbort (Node 10)
--   55
--   </pre>
--   
--   This will also execute in &lt;math&gt; space and time, all without
--   worrying about a smart solution strategy involving how to tie knots or
--   allocate vectors. Granted, this doesn't really pay off for simple
--   problems like computing fibonacci numbers because of the boilerplate
--   involved and the somewhat devious type-level story, but the intended
--   use case is that of static analysis of programming languages.
--   
--   Before I delegate you to a blog post about strictness analysis, we
--   will look at a more devious reccurence relation with actual cycles in
--   the resulting data-flow graph.
--   
--   <h1>Use Case: Solving Cyclic Recurrences</h1>
--   
--   The recurrence relation describing fibonacci numbers admits a clear
--   plan of how to compute a solution, because the dependency graph is
--   obviously acyclic: To compute the next new value of the sequence, only
--   the prior two values are needed.
--   
--   This is not true of the following reccurence relation:
--   
--   &lt;math&gt;
--   
--   The identity function is the only solution to this, but it is unclear
--   how we could arrive at that conclusion just by translating that
--   relation into Haskell:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   f n
--     | even n = 2 * f (n `div` 2)
--     | odd n  = f (n + 1) - 1
--   :}
--   </pre>
--   
--   Imagine a call <tt>f 1</tt>: This will call <tt>f 2</tt> recursively,
--   which again will call <tt>f 1</tt>. We hit a cyclic dependency!
--   
--   Fortunately, we can use <tt>datafix</tt> to compute the solution by
--   fixed-point iteration (which assumes monotonicity of the function to
--   approximate):
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferF
--       :: forall m
--        . (MonadDependency m, Domain m ~ Int)
--       =&gt; Node
--       -&gt; LiftedFunc Int m
--     transferF (Node n)
--       | even n = (* 2) &lt;$&gt; dependOn @m (Node (n `div` 2))
--       | odd n  = (subtract 1) &lt;$&gt; dependOn @m (Node (n + 1))
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fDfp :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; DataFlowProblem m
--     fDfp = DFP transferF (const (eqChangeDetector @(Domain m)))
--   :}
--   </pre>
--   
--   Specification of the data-flow problem works the same as for the
--   <tt>fib</tt> function.
--   
--   As for <tt>Natural</tt>, we need an instance of
--   <tt>BoundedJoinSemiLattice</tt> for <a>Int</a> to compute a solution:
--   
--   <pre>
--   &gt;&gt;&gt; instance JoinSemiLattice Int where (\/) = max
--   
--   &gt;&gt;&gt; instance BoundedJoinSemiLattice Int where bottom = minBound
--   </pre>
--   
--   Now it's just a matter of calling <a>solveProblem</a> with the right
--   parameters:
--   
--   <pre>
--   &gt;&gt;&gt; solveProblem fDfp Sparse NeverAbort (Node 0)
--   0
--   
--   &gt;&gt;&gt; solveProblem fDfp Sparse NeverAbort (Node 5)
--   5
--   
--   &gt;&gt;&gt; solveProblem fDfp Sparse NeverAbort (Node 42)
--   42
--   
--   &gt;&gt;&gt; solveProblem fDfp Sparse NeverAbort (Node (-10))
--   -10
--   </pre>
--   
--   Note how the <i>specification</i> of the data-flow problem was as
--   unexciting as it was for the fibonacci sequence (modulo boilerplate),
--   yet the recurrence we solved was pretty complicated already.
--   
--   Of course, encoding the identity function this way is inefficient. But
--   keep in mind that in general, we don't know the solution to a
--   particular recurrence! It's always possible to solve the recurrence by
--   hand upfront, but that's trading precious developer time for what
--   might be a throw-away problem anyway.
--   
--   Which brings us to the prime and final use case...
--   
--   <h1>Use Case: Static Analysis</h1>
--   
--   Recurrence equations occur <i>all the time</i> in denotational
--   semantics and static data-flow analysis.
--   
--   For every invocation of the compiler, for every module, for every
--   analysis within the compiler, a recurrence relation representing
--   program semantics is to be solved. Naturally, we can't task a human
--   with solving a bunch of complicated recurrences everytime we hit
--   compile.
--   
--   In the imperative world, it's common-place to have some kind of
--   fixed-point iteration framework carry out the iteration of the
--   data-flow graph, but I could not find a similar abstraction for
--   functional programming languages yet. Analyses for functional
--   languages are typically carried out as iterated traversals of the
--   syntax tree, but that is unsatisfying for a number of reasons:
--   
--   <ol>
--   <li>Solution logic of the data-flow problem is intertwined with its
--   specification.</li>
--   <li>Solution logic is duplicated among multiple analyses, violating
--   DRY.</li>
--   <li>A consequence of the last two points is that performance tweaks
--   have to be adapted for every analysis separately. In the case of GHC's
--   Demand Analyser, going from chaotic iteration (which corresponds to
--   naive iterated tree traversals) to an iteration scheme that caches
--   results of inner let-bindings, annotations to the syntax tree are
--   suddenly used like <tt>State</tt> threads, which makes the analysis
--   logic even more complex than it already was.</li>
--   </ol>
--   
--   So, I can only encourage any compiler dev who wants to integrate
--   static analyses into their compiler to properly specify the data-flow
--   problems in terms of <tt>datafix</tt> and leave the intricacies of
--   finding a good iteration order to this library :)
module Datafix.Tutorial
