<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Datafix.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Datafix.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">datafix-0.0.0.2: Fixing data-flow problems</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Sebastian Graf 2018</td></tr><tr><th>License</th><td>ISC</td></tr><tr><th>Maintainer</th><td>sgraf1337@gmail.com</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Datafix.Tutorial</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>What is This?</h1><p>The purpose of <code>datafix</code> is to separate declaring
 <a href="https://en.wikipedia.org/wiki/Data-flow_analysis">data-flow problems</a>
 from computing their solutions by
 <a href="https://en.wikipedia.org/wiki/Fixed-point_iteration">fixed-point iteration</a>.</p><p>The need for this library arose when I was combining two analyses
 within GHC for my master's thesis. I recently
 <a href="https://cdn.rawgit.com/sgraf812/hiw17/2645b206d3f2b5e6e7c95bc791dfa4bf9cbc8d12/slides.pdf">held a talk</a>
 on that topic, feel free to click through if you want to know the details.</p><p>You can think of data-flow problems as problems that are solvable by
 <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>
 or <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>,
 except that the dependency graph of data-flow problems doesn't need to be
 acyclic.</p><p>Data-flow problems are declared with the primitives in
 <code><a href="Datafix-Description.html">Datafix.Description</a></code> and solved by <code>Datafix.Worklist.<code><a href="Datafix-Worklist-Internal.html#v:solveProblem">solveProblem</a></code></code>.</p><p>With that out of the way, let's set in place the GHCi environment of our
 examples:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XScopedTypeVariables
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XTypeApplications
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XTypeFamilies
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Datafix
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Proxy (Proxy (..))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Algebra.Lattice (JoinSemiLattice (..), BoundedJoinSemiLattice (..))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Numeric.Natural
</code></strong></pre><h1>Use Case: Solving Recurrences</h1><p>Let's start out by computing the fibonacci series:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  fib :: Natural -&gt; Natural
  fib 0 = 0
  fib 1 = 1
  fib n = fib (n-1) + fib (n-2)
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fib 3
</code></strong>2
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fib 10
</code></strong>55
</pre><p>Bring your rabbits to the vet while you can still count them...</p><p>Anyway, the fibonacci series is a typical problem exhibiting
 <em>overlapping subproblems</em>. As a result, our <code>fib</code> function from above scales badly in
 the size of its input argument <code>n</code>. Because we repeatedly recompute
 solutions, the time complexity of our above function is in \(\mathcal{O}(2^n)\)!</p><p>We can do better by using <em>dynamic programming</em> or <em>memoization</em> to keep a
 cache of already computed sub-problems, which helps computing the \(n\)th
 item in \(\mathcal{O}(n)\) time and space:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  fib2 :: Natural -&gt; Natural
  fib2 n = fibs !! fromIntegral n
    where
      fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fib2 3
</code></strong>2
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fib2 10
</code></strong>55
</pre><p>That's one of Haskell's pet issues: Expressing dynamic programs as lists
 through laziness.</p><p>As promised in the previous section, we can do the same using <code>datafix</code>.
 First, we need to declare a <em>transfer function</em> that makes the data
 dependencies for the recursive case explicit, as if we were using
 <code><a href="../base-4.10.1.0/Data-Function.html#v:fix">fix</a></code> to eliminate the recursion:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  transferFib
    :: forall m
     . (MonadDependency m, Domain m ~ Natural)
    =&gt; Node
    -&gt; LiftedFunc Natural m
  transferFib (Node 0) = return 0
  transferFib (Node 1) = return 1
  transferFib (Node n) = do
    a &lt;- dependOn @m (Node (n-1))
    b &lt;- dependOn @m (Node (n-2))
    return (a + b)
:}
</pre><p><code><a href="Datafix-Explicit.html#t:MonadDependency">MonadDependency</a></code> contains a single primitive <code><a href="Datafix-Explicit.html#v:dependOn">dependOn</a></code> for that purpose.</p><p>Every point of the fibonacci series is modeled as a seperate <code><a href="Datafix-Explicit.html#t:Node">Node</a></code> of the
 data-flow graph.
 By looking at the definition of <code><a href="Datafix-Common.html#t:LiftedFunc">LiftedFunc</a></code>, we can see that
 <code>LiftedFunc Natural m ~ m Natural</code>, so for our simple
 <code>Natural</code> <code><a href="Datafix-Common.html#t:Domain">Domain</a></code>, the transfer function is specified directly in
 <code><a href="Datafix-Explicit.html#t:MonadDependency">MonadDependency</a></code>.</p><p>Note that indeed we eliminated explicit recursion in <code>transferFib</code>.
 This allows the solution algorithm to track and discover dependencies
 of the transfer function as it is executed!</p><p>With our transfer function (which denotes data-flow nodes in the semantics
 of <code>Natural</code>s) in place, we can construct a <code><a href="Datafix-Explicit.html#t:DataFlowProblem">DataFlowProblem</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  fibDfp :: forall m . (MonadDependency m, Domain m ~ Natural) =&gt; DataFlowProblem m
  fibDfp = DFP transferFib (const (eqChangeDetector @(Domain m)))
:}
</pre><p>The <code><a href="Datafix-Common.html#v:eqChangeDetector">eqChangeDetector</a></code> is important for cyclic dependency graphs and makes
 sure we detect when a fixed-point has been reached.</p><p>That's it for describing the data-flow problem of fibonacci numbers.
 We can ask <code>Datafix.Worklist.<code><a href="Datafix-Worklist-Internal.html#v:solveProblem">solveProblem</a></code></code> for a solution in a minute.</p><p>The <code><a href="Datafix-Worklist-Internal.html#v:solveProblem">solveProblem</a></code> solver demands an instance of <code>BoundedJoinSemiLattice</code>
 on the <code><a href="Datafix-Common.html#t:Domain">Domain</a></code> for when the data-flow graph is cyclic. We conveniently
 delegate to the total <code>Ord</code> instance for <code><a href="../base-4.10.1.0/Numeric-Natural.html#v:Natural">Natural</a></code>, knowing
 that its semantic interpretation is irrelevant to us:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance JoinSemiLattice Natural where (\/) = max
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance BoundedJoinSemiLattice Natural where bottom = 0
</code></strong></pre><p>And now the final incantation of the solver:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveProblem fibDfp Sparse NeverAbort (Node 10)
</code></strong>55
</pre><p>This will also execute in \(\mathcal{O}(n)\) space and time, all without
 worrying about a smart solution strategy involving how to tie knots or
 allocate vectors.
 Granted, this doesn't really pay off for simple problems like computing
 fibonacci numbers because of the boilerplate involved and the somewhat
 devious type-level story, but the intended use case is that of static
 analysis of programming languages.</p><p>Before I delegate you to a blog post about strictness analysis,
 we will look at a more devious reccurence relation with actual
 cycles in the resulting data-flow graph.</p><h1>Use Case: Solving Cyclic Recurrences</h1><p>The recurrence relation describing fibonacci numbers admits a clear
 plan of how to compute a solution, because the dependency graph is
 obviously acyclic: To compute the next new value of the sequence,
 only the prior two values are needed.</p><p>This is not true of the following reccurence relation:</p><p>\[
 f(n) = \begin{cases}
   2 \cdot f(\frac{n}{2}), &amp; n \text{ even}\\
   f(n+1)-1, &amp; n \text{ odd}
 \end{cases}
 \]</p><p>The identity function is the only solution to this, but it is unclear
 how we could arrive at that conclusion just by translating that relation
 into Haskell:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>f n
  | even n = 2 * f (n `div` 2)
  | odd n  = f (n + 1) - 1
:}
</pre><p>Imagine a call <code>f 1</code>: This will call <code>f 2</code> recursively, which again
 will call <code>f 1</code>. We hit a cyclic dependency!</p><p>Fortunately, we can use <code>datafix</code> to compute the solution by fixed-point
 iteration (which assumes monotonicity of the function to approximate):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  transferF
    :: forall m
     . (MonadDependency m, Domain m ~ Int)
    =&gt; Node
    -&gt; LiftedFunc Int m
  transferF (Node n)
    | even n = (* 2) &lt;$&gt; dependOn @m (Node (n `div` 2))
    | odd n  = (subtract 1) &lt;$&gt; dependOn @m (Node (n + 1))
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  fDfp :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; DataFlowProblem m
  fDfp = DFP transferF (const (eqChangeDetector @(Domain m)))
:}
</pre><p>Specification of the data-flow problem works the same as for the <code>fib</code>
 function.</p><p>As for <code>Natural</code>, we need an instance of <code>BoundedJoinSemiLattice</code>
 for <code><a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a></code> to compute a solution:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance JoinSemiLattice Int where (\/) = max
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance BoundedJoinSemiLattice Int where bottom = minBound
</code></strong></pre><p>Now it's just a matter of calling <code><a href="Datafix-Worklist-Internal.html#v:solveProblem">solveProblem</a></code> with the right parameters:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveProblem fDfp Sparse NeverAbort (Node 0)
</code></strong>0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveProblem fDfp Sparse NeverAbort (Node 5)
</code></strong>5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveProblem fDfp Sparse NeverAbort (Node 42)
</code></strong>42
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveProblem fDfp Sparse NeverAbort (Node (-10))
</code></strong>-10
</pre><p>Note how the <em>specification</em> of the data-flow problem was as unexciting as
 it was for the fibonacci sequence (modulo boilerplate), yet the recurrence
 we solved was pretty complicated already.</p><p>Of course, encoding the identity function this way is inefficient.
 But keep in mind that in general, we don't know the solution to a particular
 recurrence! It's always possible to solve the recurrence by hand upfront,
 but that's trading precious developer time for what might be a throw-away
 problem anyway.</p><p>Which brings us to the prime and final use case...</p><h1>Use Case: Static Analysis</h1><p>Recurrence equations occur <em>all the time</em> in denotational
 semantics and static data-flow analysis.</p><p>For every invocation of the compiler, for every module, for every analysis
 within the compiler, a recurrence relation representing program semantics
 is to be solved. Naturally, we can't task a human with solving a bunch of
 complicated recurrences everytime we hit compile.</p><p>In the imperative world, it's common-place to have some kind of fixed-point
 iteration framework carry out the iteration of the data-flow graph, but
 I could not find a similar abstraction for functional programming languages
 yet. Analyses for functional languages are typically carried out as iterated
 traversals of the syntax tree, but that is unsatisfying for a number of
 reasons:</p><ol><li>Solution logic of the data-flow problem is intertwined with its
      specification.</li><li>Solution logic is duplicated among multiple analyses, violating DRY.</li><li>A consequence of the last two points is that performance tweaks
      have to be adapted for every analysis separately.
      In the case of GHC's Demand Analyser, going from chaotic iteration
      (which corresponds to naive iterated tree traversals) to an iteration
      scheme that caches results of inner let-bindings, annotations to the
      syntax tree are suddenly used like <code>State</code> threads, which makes
      the analysis logic even more complex than it already was.</li></ol><p>So, I can only encourage any compiler dev who wants to integrate static
 analyses into their compiler to properly specify the data-flow problems
 in terms of <code>datafix</code> and leave the intricacies of finding a good iteration
 order to this library :)</p></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>