-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fixing data-flow problems
--   
--   Fixing data-flow problems in expression trees
@package datafix
@version 0.0.0.1


-- | A uniform interface for ordered maps that can be used to model
--   monotone functions.
module Datafix.MonoMap

-- | Chooses an appropriate <a>MonoMap</a> for a given key type.
--   
--   <tt>MonoMap</tt>s should all be ordered maps, which feature efficient
--   variants of the <a>lookupLT</a> and <a>lookupMin</a> combinators. This
--   unifies <a>Data.Maybe</a>, <a>Data.IntMap.Strict</a>,
--   <a>Data.Map.Strict</a> and <a>Data.POMap.Strict</a> under a common
--   type class, for which instances can delegate to the most efficient
--   variant available.
--   
--   Because of <a>lookupLT</a>, this class lends itself well to
--   approximating monotone functions.
--   
--   The default implementation delegates to <a>POMap</a>, so when there is
--   no specially crafted map data-structure for your key type, all you
--   need to do is to make sure it satisfies <a>PartialOrd</a>. Then you
--   can do
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IntSet
--   
--   &gt;&gt;&gt; instance MonoMapKey IntSet
--   </pre>
--   
--   to make use of the default implementation.
class Foldable (MonoMap k) => MonoMapKey k where {
    type family MonoMap k = (r :: * -> *) | r -> k;
    type MonoMap k = POMap k;
}
empty :: MonoMapKey k => MonoMap k v
empty :: (MonoMapKey k, (MonoMap k v ~ POMap k v)) => MonoMap k v
singleton :: MonoMapKey k => k -> v -> MonoMap k v
singleton :: (MonoMapKey k, (MonoMap k v ~ POMap k v)) => k -> v -> MonoMap k v
insert :: MonoMapKey k => k -> v -> MonoMap k v -> MonoMap k v
insert :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> v -> MonoMap k v -> MonoMap k v
delete :: MonoMapKey k => k -> MonoMap k v -> MonoMap k v
delete :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> MonoMap k v
lookup :: MonoMapKey k => k -> MonoMap k v -> Maybe v
lookup :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> Maybe v

-- | Key point of this interface! Note that it returns a list of lower
--   bounds, to account for the <a>PartialOrd</a> case.
lookupLT :: MonoMapKey k => k -> MonoMap k v -> [(k, v)]

-- | Key point of this interface! Note that it returns a list of lower
--   bounds, to account for the <a>PartialOrd</a> case.
lookupLT :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => k -> MonoMap k v -> [(k, v)]
lookupMin :: MonoMapKey k => MonoMap k v -> [(k, v)]
lookupMin :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => MonoMap k v -> [(k, v)]
difference :: MonoMapKey k => MonoMap k a -> MonoMap k b -> MonoMap k a
difference :: (MonoMapKey k, MonoMap k a ~ POMap k a, MonoMap k b ~ POMap k b, PartialOrd k) => MonoMap k a -> MonoMap k b -> MonoMap k a
keys :: MonoMapKey k => MonoMap k a -> [k]
keys :: (MonoMapKey k, MonoMap k v ~ POMap k v) => MonoMap k v -> [k]
insertWith :: MonoMapKey k => (v -> v -> v) -> k -> v -> MonoMap k v -> MonoMap k v
insertWith :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (v -> v -> v) -> k -> v -> MonoMap k v -> MonoMap k v
insertLookupWithKey :: MonoMapKey k => (k -> v -> v -> v) -> k -> v -> MonoMap k v -> (Maybe v, MonoMap k v)
insertLookupWithKey :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (k -> v -> v -> v) -> k -> v -> MonoMap k v -> (Maybe v, MonoMap k v)
updateLookupWithKey :: MonoMapKey k => (k -> v -> Maybe v) -> k -> MonoMap k v -> (Maybe v, MonoMap k v)
updateLookupWithKey :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (k -> v -> Maybe v) -> k -> MonoMap k v -> (Maybe v, MonoMap k v)
alter :: MonoMapKey k => (Maybe v -> Maybe v) -> k -> MonoMap k v -> MonoMap k v
alter :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (Maybe v -> Maybe v) -> k -> MonoMap k v -> MonoMap k v
adjust :: MonoMapKey k => (v -> v) -> k -> MonoMap k v -> MonoMap k v
adjust :: (MonoMapKey k, MonoMap k v ~ POMap k v, PartialOrd k) => (v -> v) -> k -> MonoMap k v -> MonoMap k v

-- | Delegates to <a>Maybe</a>.

-- | Delegates to <a>IntMap</a>.
instance Datafix.MonoMap.MonoMapKey ()
instance Datafix.MonoMap.MonoMapKey GHC.Types.Int


-- | Some type-level helpers for 'curry'/'uncurry'ing arbitrary function
--   types.
module Datafix.Utils.TypeLevel

-- | <tt>All p as</tt> ensures that the constraint <tt>p</tt> is satisfied
--   by all the <tt>types</tt> in <tt>as</tt>. (Types is between
--   scare-quotes here because the code is actually kind polymorphic)

-- | On Booleans

-- | On Lists

-- | Version of <tt>Foldr</tt> taking a defunctionalised argument so that
--   we can use partially applied functions.
data ConsMap0 :: (Function k l -> *) -> Function k (Function [l] [l] -> *) -> *
data ConsMap1 :: (Function k l -> *) -> k -> Function [l] [l] -> *

-- | <tt>Arrows [a1,..,an] r</tt> corresponds to <tt>a1 -&gt; .. -&gt; an
--   -&gt; r</tt>
type Arrows (as :: [*]) (r :: *) = Foldr (->) r as

-- | <tt>Products []</tt> corresponds to <tt>()</tt>, <tt>Products [a]</tt>
--   corresponds to <tt>a</tt>, <tt>Products [a1,..,an]</tt> corresponds to
--   <tt>(a1, (..,( an)..))</tt>.
--   
--   So, not quite a right fold, because we want to optimize for the empty,
--   singleton and pair case.

-- | <tt>IsBase t</tt> is <tt>'True</tt> whenever <tt>t</tt> is *not* a
--   function space.

-- | Using <tt>IsBase</tt> we can define notions of <tt>ParamTypes</tt> and
--   <tt>ReturnTypes</tt> which *reduce* under positive information
--   <tt>IsBase t ~ 'True</tt> even though the shape of <tt>t</tt> is not
--   formally exposed

-- | <tt>Currying as b</tt> witnesses the isomorphism between <tt>Arrows as
--   b</tt> and <tt>Products as -&gt; b</tt>. It is defined as a type class
--   rather than by recursion on a singleton for <tt>as</tt> so all of that
--   these conversions are inlined at compile time for concrete arguments.
class Currying as b
uncurrys :: Currying as b => Proxy as -> Proxy b -> Arrows as b -> Products as -> b
currys :: Currying as b => Proxy as -> Proxy b -> (Products as -> b) -> Arrows as b
data Function :: * -> * -> *
data Constant0 :: Function a (Function b a -> *) -> *
data Constant1 :: * -> Function b a -> *
instance Datafix.Utils.TypeLevel.Currying '[] b
instance Datafix.Utils.TypeLevel.Currying '[a] b
instance Datafix.Utils.TypeLevel.Currying (a2 : as) b => Datafix.Utils.TypeLevel.Currying (a1 : a2 : as) b


-- | Primitives for describing a <a>data-flow problem</a> in a declarative
--   manner.
--   
--   Import this module transitively through <a>Datafix</a> and get access
--   to <a>Datafix.Worklist</a> for functions that compute solutions to
--   your <a>DataFlowProblem</a>s.
module Datafix.Description

-- | This is the type we use to index nodes in the data-flow graph.
--   
--   The connection between syntactic things (e.g. <tt>Id</tt>s) and
--   <a>Node</a>s is made implicitly in code in analysis templates through
--   an appropriate allocation mechanism as in <tt>NodeAllocator</tt>.
newtype Node
Node :: Int -> Node

-- | Data-flow problems denote <a>Node</a>s in the data-flow graph by
--   monotone transfer functions.
--   
--   This type alias alone carries no semantic meaning. However, it is
--   instructive to see some examples of how this alias reduces to a normal
--   form:
--   
--   <pre>
--   TransferFunction m Int ~ m Int
--   TransferFunction m (Bool -&gt; Int) ~ Bool -&gt; m Int
--   TransferFunction m (a -&gt; b -&gt; Int) ~ a -&gt; b -&gt; m Int
--   TransferFunction m (a -&gt; b -&gt; c -&gt; Int) ~ a -&gt; b -&gt; c -&gt; m Int
--   </pre>
--   
--   <tt>m</tt> will generally be an instance of <a>MonadDependency</a> and
--   the type alias effectively wraps <tt>m</tt> around <tt>domain</tt>'s
--   return type. The result is a function that is produces its return
--   value while potentially triggering side-effects in <tt>m</tt>, which
--   amounts to depending on <a>TransferFunction</a>s of other <a>Node</a>s
--   for the <a>MonadDependency</a> case.
type TransferFunction m domain = Arrows (ParamTypes domain) (m (ReturnType domain))

-- | A function that checks points of some function with type
--   <tt>domain</tt> for changes. If this returns <a>True</a>, the point of
--   the function is assumed to have changed.
--   
--   An example is worth a thousand words, especially because of the
--   type-level hackery:
--   
--   <pre>
--   &gt;&gt;&gt; cd = (\a b -&gt; even a /= even b) :: ChangeDetector Int
--   </pre>
--   
--   This checks the parity for changes in the abstract domain of integers.
--   Integers of the same parity are considered unchanged.
--   
--   <pre>
--   &gt;&gt;&gt; cd 4 5
--   True
--   
--   &gt;&gt;&gt; cd 7 13
--   False
--   </pre>
--   
--   Now a (quite bogus) pointwise example:
--   
--   <pre>
--   &gt;&gt;&gt; cd = (\x fx gx -&gt; x + abs fx /= x + abs gx) :: ChangeDetector (Int -&gt; Int)
--   
--   &gt;&gt;&gt; cd 1 (-1) 1
--   False
--   
--   &gt;&gt;&gt; cd 15 1 2
--   True
--   
--   &gt;&gt;&gt; cd 13 35 (-35)
--   False
--   </pre>
--   
--   This would consider functions <tt>id</tt> and <tt>negate</tt>
--   unchanged, so the sequence <tt>iterate negate :: Int -&gt; Int</tt>
--   would be regarded immediately as convergent:
--   
--   <pre>
--   &gt;&gt;&gt; f x = iterate negate x !! 0
--   
--   &gt;&gt;&gt; let g x = iterate negate x !! 1
--   
--   &gt;&gt;&gt; cd 123 (f 123) (g 123)
--   False
--   </pre>
type ChangeDetector domain = Arrows (ParamTypes domain) (ReturnType domain -> ReturnType domain -> Bool)

-- | Models a data-flow problem, where each <a>Node</a> is mapped to its
--   denoting <a>TransferFunction</a> and a means to detect when the
--   iterated transfer function reached a fixed-point through a
--   <a>ChangeDetector</a>.
data DataFlowProblem m
DFP :: !(Node -> TransferFunction m (Domain m)) -> !(Node -> ChangeDetector (Domain m)) -> DataFlowProblem m

-- | A transfer function per each <a>Node</a> of the modeled data-flow
--   problem.
[dfpTransfer] :: DataFlowProblem m -> !(Node -> TransferFunction m (Domain m))

-- | A <a>ChangeDetector</a> for each <a>Node</a> of the modeled data-flow
--   problem. In the simplest case, this just delegates to an <a>Eq</a>
--   instance.
[dfpDetectChange] :: DataFlowProblem m -> !(Node -> ChangeDetector (Domain m))

-- | A monad with a single impure primitive <a>dependOn</a> that expresses
--   a dependency on a <a>Node</a> of a data-flow graph.
--   
--   The associated <a>Domain</a> type is the abstract domain in which we
--   denote <a>Node</a>s.
--   
--   Think of it like memoization on steroids. You can represent dynamic
--   programs with this quite easily:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferFib :: (MonadDependency m, Domain m ~ Int) =&gt; Proxy m -&gt; Node -&gt; TransferFunction m Int
--     transferFib _ (Node 0) = return 0
--     transferFib _ (Node 1) = return 1
--     transferFib p (Node n) = (+) &lt;$&gt; dependOn p (Node (n-1)) &lt;*&gt; dependOn p (Node (n-2))
--     -- sparing the negative n error case
--   :}
--   </pre>
--   
--   We can construct a description of a <a>DataFlowProblem</a> with this
--   <tt>transferFib</tt> function:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     dataFlowProblem :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; DataFlowProblem m
--     dataFlowProblem = DFP (transferFib (Proxy :: Proxy m)) (const (eqChangeDetector (Proxy :: Proxy m)))
--   :}
--   </pre>
--   
--   We regard the ordinary <tt>fib</tt> function a solution to the
--   recurrence modeled by <tt>transferFib</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib :: Int -&gt; Int
--     fib 0 = 0
--     fib 1 = 1
--     fib n = fib (n-1) + fib (n - 2)
--   :}
--   </pre>
--   
--   E.g., under the assumption of <tt>fib</tt> being total (which is true
--   on the domain of natural numbers), it computes the same results as the
--   least <i>fixed-point</i> of the series of iterations of the transfer
--   function <tt>transferFib</tt>.
--   
--   Ostensibly, the nth iteration of <tt>transferFib</tt> substitutes each
--   <tt>dependOn</tt> with <tt>transferFib</tt> repeatedly for n times and
--   finally substitutes all remaining <tt>dependOn</tt>s with a call to
--   <a>error</a>.
--   
--   Computing a solution by <i>fixed-point iteration</i> in a declarative
--   manner is the purpose of this library. There potentially are different
--   approaches to computing a solution, but in <a>Datafix.Worklist</a> we
--   offer an approach based on a worklist algorithm, trying to find a
--   smart order in which nodes in the data-flow graph are reiterated.
--   
--   The concrete MonadDependency depends on the solution algorithm, which
--   is in fact the reason why there is no satisfying data type in this
--   module: We are only concerned with <i>declaring</i> data-flow problems
--   here.
--   
--   The distinguishing feature of data-flow graphs is that they are not
--   necessarily acyclic (data-flow graphs of dynamic programs always
--   are!), but <a>under certain conditions</a> even have solutions when
--   there are cycles.
--   
--   Cycles occur commonly in data-flow problems of static analyses for
--   programming languages, introduced through loops or recursive
--   functions. Thus, this library mostly aims at making the life of
--   compiler writers easier.
class Monad m => MonadDependency m where {
    type family Domain m :: *;
}

-- | Expresses a dependency on a node of the data-flow graph, thus
--   introducing a way of trackable recursion. That's similar to how you
--   would use <a>fix</a> to abstract over recursion.
dependOn :: MonadDependency m => Proxy m -> Node -> TransferFunction m (Domain m)

-- | A <a>ChangeDetector</a> that delegates to the <a>Eq</a> instance of
--   the node values.
eqChangeDetector :: forall m. Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m) -> Bool) => Eq (ReturnType (Domain m)) => Proxy m -> ChangeDetector (Domain m)

-- | A <a>ChangeDetector</a> that always returns <a>True</a>.
--   
--   Use this when recomputing a node is cheaper than actually testing for
--   the change. Beware of cycles in the resulting dependency graph,
--   though!
alwaysChangeDetector :: forall m. Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m) -> Bool) => Proxy m -> ChangeDetector (Domain m)
instance GHC.Show.Show Datafix.Description.Node
instance GHC.Classes.Ord Datafix.Description.Node
instance GHC.Classes.Eq Datafix.Description.Node


-- | Helpers for allocating <a>Node</a>s in an ergonomic manner, e.g.
--   taking care to get <a>mfix</a> right under the hood for allocation in
--   recursive bindings groups through the key primitive
--   <a>allocateNode</a>.
module Datafix.NodeAllocator

-- | A state monad wrapping a mapping from <a>Node</a> to some <tt>v</tt>
--   which we will instantiate to appropriate <a>TransferFunction</a>s.
data NodeAllocator v a

-- | Allocates the next <a>Node</a>, which is greater than any nodes
--   requested before.
--   
--   The value stored at that node is the result of a <a>NodeAllocator</a>
--   computation which may already access the <a>Node</a> associated with
--   that value. This is important for the case of recursive let, where the
--   denotation of an expression depends on itself.
allocateNode :: (Node -> NodeAllocator v (a, v)) -> NodeAllocator v a

-- | Runs the allocator, beginning with an empty mapping.
runAllocator :: NodeAllocator v a -> (a, Array v)
instance GHC.Base.Monad (Datafix.NodeAllocator.NodeAllocator v)
instance GHC.Base.Applicative (Datafix.NodeAllocator.NodeAllocator v)
instance GHC.Base.Functor (Datafix.NodeAllocator.NodeAllocator v)


-- | Abstracts over the representation of the data-flow graph.
--   
--   The contents of this module are more or less internal to the
--   <a>Datafix.Worklist</a> implementation.
module Datafix.Worklist.Graph

-- | The data associated with each point in the transfer function of a
--   data-flow <tt>Node</tt>.
data PointInfo domain
PointInfo :: !(Maybe (ReturnType domain)) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !Int -> PointInfo domain

-- | The value at this point. Can be <a>Nothing</a> only when a loop was
--   detected.
[value] :: PointInfo domain -> !(Maybe (ReturnType domain))

-- | Points this point of the transfer function depends on.
[references] :: PointInfo domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | Points depending on this point.
[referrers] :: PointInfo domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | The number of times this point has been updated through calls to
--   <tt>updateNodeValue</tt>.
[iterations] :: PointInfo domain -> !Int

-- | The default <a>PointInfo</a>.
emptyPointInfo :: PointInfo domain

-- | Diff between two <a>IntArgsMonoSet</a>s.
data Diff a
Diff :: !(IntArgsMonoSet a) -> !(IntArgsMonoSet a) -> Diff a
[added] :: Diff a -> !(IntArgsMonoSet a)
[removed] :: Diff a -> !(IntArgsMonoSet a)

-- | Computes the diff between two <a>IntArgsMonoSet</a>s.
computeDiff :: MonoMapKey k => IntArgsMonoSet k -> IntArgsMonoSet k -> Diff k

-- | Abstracts over the concrete representation of the data-flow graph.
--   
--   There are two instances: The default <a>Ref</a> for sparse graphs
--   based on an <tt>IntMap</tt> and <a>Ref</a> for the dense case, storing
--   the <tt>Node</tt> mapping in a <a>IOVector</a>.
class GraphRef (ref :: * -> *)
updatePoint :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReturnType domain -> IntArgsMonoSet (Products (ParamTypes domain)) -> ReaderT (ref domain) IO (PointInfo domain)
lookup :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReaderT (ref domain) IO (Maybe (PointInfo domain))
lookupLT :: (GraphRef ref, MonoMapKey (Products (ParamTypes domain))) => Int -> Products (ParamTypes domain) -> ReaderT (ref domain) IO [(Products (ParamTypes domain), PointInfo domain)]
instance (GHC.Classes.Eq (Datafix.Utils.TypeLevel.ReturnType domain), GHC.Classes.Eq (Datafix.IntArgsMonoSet.IntArgsMonoSet (Datafix.Utils.TypeLevel.Products (Datafix.Utils.TypeLevel.ParamTypes domain)))) => GHC.Classes.Eq (Datafix.Worklist.Graph.PointInfo domain)
instance (GHC.Show.Show (Datafix.Utils.TypeLevel.ReturnType domain), GHC.Show.Show (Datafix.IntArgsMonoSet.IntArgsMonoSet (Datafix.Utils.TypeLevel.Products (Datafix.Utils.TypeLevel.ParamTypes domain)))) => GHC.Show.Show (Datafix.Worklist.Graph.PointInfo domain)


-- | Dense data-flow graph representation based on <a>IOVector</a>.
module Datafix.Worklist.Graph.Dense

-- | Reference to a dense data-flow graph representation.
data Ref domain

-- | Allocates a new dense graph <a>Ref</a>.
newRef :: MonoMapKey (Products (ParamTypes domain)) => Int -> IO (Ref domain)
instance Datafix.Worklist.Graph.GraphRef Datafix.Worklist.Graph.Dense.Ref


-- | Sparse data-flow graph representation based on <a>IntMap</a>.
module Datafix.Worklist.Graph.Sparse

-- | Reference to a sparse data-flow graph representation.
data Ref domain

-- | Allocates a new sparse graph <a>Ref</a>.
newRef :: IO (Ref domain)
instance Datafix.Worklist.Graph.GraphRef Datafix.Worklist.Graph.Sparse.Ref


-- | Internal module, does not follow the PVP. Breaking changes may happen
--   at any minor version.
module Datafix.Worklist.Internal

-- | The concrete <a>MonadDependency</a> for this worklist-based solver.
--   
--   This essentially tracks the current approximation of the solution to
--   the <a>DataFlowProblem</a> as mutable state while <a>fixProblem</a>
--   makes sure we will eventually halt with a conservative approximation.
newtype DependencyM graph domain a

-- | Why does this use <a>IO</a>? Actually, we only need <tt>ST</tt> here,
--   but that means we have to carry around the state thread in type
--   signatures.
--   
--   This ultimately leaks badly into the exported interface in
--   <a>fixProblem</a>: Since we can't have universally quantified instance
--   contexts (yet!), we can' write <tt>(forall s. Datafixable (DependencyM
--   s graph domain)) =&gt; (forall s. DataFlowProblem (DependencyM s graph
--   domain)) -&gt; ...</tt> and have to instead have the isomorphic
--   <tt>(forall s r. (Datafixable (DependencyM s graph domain) =&gt; r)
--   -&gt; r) -&gt; (forall s. DataFlowProblem (DependencyM s graph
--   domain)) -&gt; ...</tt> and urge all call sites to pass a meaningless
--   <a>id</a> parameter.
--   
--   Also, this means more explicit type signatures as we have to make
--   clear to the type-checker that <tt>s</tt> is universally quantified in
--   everything that touches it, e.g.
--   <tt>Analyses.StrAnal.LetDn.buildProblem</tt> from the test suite.
--   
--   So, bottom line: We resort to <a>IO</a> and <a>unsafePerformIO</a> and
--   promise not to launch missiles. In particular, we don't export
--   <a>DM</a> and also there must never be an instance of <tt>MonadIO</tt>
--   for this.
DM :: (ReaderT (Env graph domain) IO a) -> DependencyM graph domain a

-- | The iteration state of 'DependencyM'/'fixProblem'.
data Env graph domain
Env :: !(DataFlowProblem (DependencyM graph domain)) -> !(IterationBound domain) -> !(IntArgsMonoSet (Products (ParamTypes domain))) -> !(graph domain) -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain)))) -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain)))) -> Env graph domain

-- | Constant. The specification of the data-flow problem we ought to
--   solve.
[problem] :: Env graph domain -> !(DataFlowProblem (DependencyM graph domain))

-- | Constant. Whether to abort after a number of iterations or not.
[iterationBound] :: Env graph domain -> !(IterationBound domain)

-- | Contextual state. The set of points in the <tt>domain</tt> of
--   <a>Node</a>s currently in the call stack.
[callStack] :: Env graph domain -> !(IntArgsMonoSet (Products (ParamTypes domain)))

-- | Constant ref to stateful graph. The data-flow graph, modeling
--   dependencies between data-flow <a>Node</a>s, or rather specific points
--   in the <tt>domain</tt> of each <a>Node</a>.
[graph] :: Env graph domain -> !(graph domain)

-- | Constant (but the the wrapped queue is stateful). The set of points
--   the currently <a>recompute</a>d node references so far.
[referencedPoints] :: Env graph domain -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain))))

-- | Constant (but the the wrapped queue is stateful). Unstable nodes that
--   will be <a>recompute</a>d by the <a>work</a>list algorithm.
[unstable] :: Env graph domain -> !(IORef (IntArgsMonoSet (Products (ParamTypes domain))))
initialEnv :: IntArgsMonoSet (Products (ParamTypes domain)) -> DataFlowProblem (DependencyM graph domain) -> IterationBound domain -> IO (graph domain) -> IO (Env graph domain)

-- | A constraint synonym for the constraints <tt>m</tt> and its associated
--   <a>Domain</a> have to suffice.
--   
--   This is actually a lot less scary than you might think. Assuming we
--   got <a>quantified class constraints</a>, <tt>Datafixable</tt> is a
--   specialized version of this:
--   
--   <pre>
--   type Datafixable m =
--     ( forall r. Currying (ParamTypes (Domain m)) r
--     , MonoMapKey (Products (ParamTypes (Domain m)))
--     , BoundedJoinSemiLattice (ReturnType (Domain m))
--     )
--   </pre>
--   
--   Now, let's assume a concrete <tt>Domain m ~ String -&gt; Bool -&gt;
--   Int</tt>, so that <tt><a>ParamTypes</a> (String -&gt; Bool -&gt;
--   Int)</tt> expands to the type-level list <tt>'[String, Bool]</tt> and
--   <tt><a>Products</a> '[String, Bool]</tt> reduces to <tt>(String,
--   Bool)</tt>.
--   
--   Then this constraint makes sure we are able to
--   
--   <ol>
--   <li>Curry the domain of <tt>String -&gt; Bool -&gt; r</tt> for all
--   <tt>r</tt> to e.g. <tt>(String, Bool) -&gt; r</tt>. See
--   <a>Currying</a>. This constraint should always be discharged
--   automatically by the type-checker as soon as <a>ParamTypes</a> and
--   <tt>ReturnTypes</tt> reduce for the <a>Domain</a> argument, which
--   happens when the concrete <tt><a>MonadDependency</a> m</tt> is
--   known.(Actually, we do this for multiple concrete <tt>r</tt> because
--   of the missing support for quantified class constraints)</li>
--   <li>We want to use a <a>monotone</a> map of <tt>(String, Bool)</tt> to
--   <tt>Int</tt> (the <tt>ReturnType (Domain m)</tt>). This is ensured by
--   the <tt><a>MonoMapKey</a> (String, Bool)</tt> constraint.This
--   constraint has to be discharged manually, but should amount to a
--   single line of boiler-plate in most cases, see <a>MonoMapKey</a>.Note
--   that the monotonicity requirement means we have to pull non-monotone
--   arguments in <tt>Domain m</tt> into the <a>Node</a> portion of the
--   <a>DataFlowProblem</a>.</li>
--   <li>For fixed-point iteration to work at all, the values which we
--   iterate naturally have to be instances of
--   <a>BoundedJoinSemiLattice</a>. That type-class allows us to start
--   iteration from a most-optimistic <a>bottom</a> value and successively
--   iterate towards a conservative approximation using the '(/)'
--   operator.</li>
--   </ol>
type Datafixable m = (Currying (ParamTypes (Domain m)) (ReturnType (Domain m)), Currying (ParamTypes (Domain m)) (m (ReturnType (Domain m))), Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m) -> Bool), Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m)), MonoMapKey (Products (ParamTypes (Domain m))), BoundedJoinSemiLattice (ReturnType (Domain m)))

-- | This allows us to solve <tt>MonadDependency m =&gt; DataFlowProblem
--   m</tt> descriptions with <a>fixProblem</a>. The <a>Domain</a> is
--   extracted from a type parameter.

-- | Specifies the <i>density</i> of the problem, e.g. whether the domain
--   of <a>Node</a>s can be confined to a finite range, in which case
--   <a>fixProblem</a> tries to use a <a>Data.Vector</a> based graph
--   representation rather than one based on <a>Data.IntMap</a>.
data Density graph
[Sparse] :: Density Ref
[Dense] :: Node -> Density Ref

-- | A function that computes a sufficiently conservative approximation of
--   a point in the abstract domain for when the solution algorithm decides
--   to have iterated the node often enough.
--   
--   When <tt>domain</tt> is a 'BoundedMeetSemilattice'/'BoundedLattice',
--   the simplest abortion function would be to constantly return
--   <a>top</a>.
--   
--   As is the case for <a>TransferFunction</a> and <a>ChangeDetector</a>,
--   this carries little semantic meaning if viewed in isolation, so here
--   are a few examples for how the synonym expands:
--   
--   <pre>
--   AbortionFunction Int ~ Int -&gt; Int
--   AbortionFunction (String -&gt; Int) ~ String -&gt; Int -&gt; Int
--   AbortionFunction (a -&gt; b -&gt; c -&gt; PowerSet) ~ a -&gt; b -&gt; c -&gt; PowerSet -&gt; PowerSet
--   </pre>
--   
--   E.g., the current value of the point is passed in (the tuple <tt>(a,
--   b, c, PowerSet)</tt>) and the function returns an appropriate
--   conservative approximation in that point.
type AbortionFunction domain = Arrows (ParamTypes domain) (ReturnType domain -> ReturnType domain)

-- | Aborts iteration of a value by <a>const</a>antly returning the
--   <a>top</a> element of the assumed <a>BoundedMeetSemiLattice</a> of the
--   <a>ReturnType</a>.
abortWithTop :: forall domain. Currying (ParamTypes domain) (ReturnType domain -> ReturnType domain) => BoundedMeetSemiLattice (ReturnType domain) => AbortionFunction domain

-- | Expresses that iteration should or shouldn't stop after a point has
--   been iterated a finite number of times.
data IterationBound domain

-- | Will keep on iterating until a precise, yet conservative approximation
--   has been reached. Make sure that your <tt>domain</tt> satisfies the
--   <a>ascending chain condition</a>, e.g. that fixed-point iteration
--   always comes to a halt!
NeverAbort :: IterationBound domain

-- | For when your <tt>domain</tt> doesn't satisfy the ascending chain
--   condition or when you are sensitive about solution performance.
--   
--   The <a>Int</a>eger determines the maximum number of iterations of a
--   single point of a <a>Node</a> (with which an entire function with many
--   points may be associated) before iteration aborts in that point by
--   calling the supplied <a>AbortionFunction</a>. The responsibility of
--   the <a>AbortionFunction</a> is to find a sufficiently conservative
--   approximation for the current value at that point.
--   
--   When your <a>ReturnType</a> is an instance of
--   <a>BoundedMeetSemiLattice</a>, <a>abortWithTop</a> might be a
--   worthwhile option. A more sophisticated solution would trim the
--   current value to a certain cut-off depth, depending on the first
--   parameter, instead.
AbortAfter :: Int -> (AbortionFunction domain) -> IterationBound domain
zoomIORef :: State s a -> ReaderT (IORef s) IO a
zoomReferencedPoints :: State (IntArgsMonoSet (Products (ParamTypes domain))) a -> ReaderT (Env graph domain) IO a
zoomUnstable :: State (IntArgsMonoSet (Products (ParamTypes domain))) a -> ReaderT (Env graph domain) IO a
enqueueUnstable :: k ~ Products (ParamTypes domain) => MonoMapKey k => Int -> k -> ReaderT (Env graph domain) IO ()
deleteUnstable :: k ~ Products (ParamTypes domain) => MonoMapKey k => Int -> k -> ReaderT (Env graph domain) IO ()
highestPriorityUnstableNode :: k ~ Products (ParamTypes domain) => MonoMapKey k => ReaderT (Env graph domain) IO (Maybe (Int, k))
withCall :: Datafixable (DependencyM graph domain) => Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO a -> ReaderT (Env graph domain) IO a

-- | The first of the two major functions of this module.
--   
--   'recompute node args' iterates the value of the passed <tt>node</tt>
--   at the point <tt>args</tt> by invoking its <a>TransferFunction</a>. It
--   does so in a way that respects the <a>IterationBound</a>.
--   
--   This function is not exported, and is only called by <a>work</a> and
--   <a>dependOn</a>, for when the iteration strategy decides that the
--   <tt>node</tt> needs to be (and can be) re-iterated. It performs
--   tracking of which <a>Node</a>s the <a>TransferFunction</a> depended
--   on, do that the worklist algorithm can do its magic.
recompute :: forall domain graph dom cod. dom ~ ParamTypes domain => cod ~ ReturnType domain => GraphRef graph => Datafixable (DependencyM graph domain) => Int -> Products dom -> ReaderT (Env graph domain) IO cod
dependOn :: forall domain graph. Datafixable (DependencyM graph domain) => GraphRef graph => Proxy (DependencyM graph domain) -> Node -> TransferFunction (DependencyM graph domain) domain

-- | Compute an optimistic approximation for a point of a given node that
--   is as precise as possible, given the other points of that node we
--   already computed.
--   
--   E.g., it is always valid to return <a>bottom</a> from this, but in
--   many cases we can be more precise since we possibly have computed
--   points for the node that are lower bounds to the current point.
optimisticApproximation :: GraphRef graph => Datafixable (DependencyM graph domain) => Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | scheme 1 (see
--   <a>https://github.com/sgraf812/journal/blob/09f0521dbdf53e7e5777501fc868bb507f5ceb1a/datafix.md.html#how-an-algorithm-that-can-do-3-looks-like)</a>.
--   
--   Let the worklist algorithm figure things out.
scheme1 :: GraphRef graph => Datafixable (DependencyM graph domain) => Maybe (ReturnType domain) -> Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | scheme 2 (see
--   <a>https://github.com/sgraf812/journal/blob/09f0521dbdf53e7e5777501fc868bb507f5ceb1a/datafix.md.html#how-an-algorithm-that-can-do-3-looks-like)</a>.
--   
--   Descend into &lt;math&gt; nodes when there is no cycle to discover the
--   set of reachable nodes as quick as possible. Do *not* descend into
--   unstable, non-(bot) nodes.
scheme2 :: GraphRef graph => Datafixable (DependencyM graph domain) => Maybe (ReturnType domain) -> Int -> Products (ParamTypes domain) -> ReaderT (Env graph domain) IO (ReturnType domain)

-- | As long as the supplied <a>Maybe</a> expression returns "Just _", the
--   loop body will be called and passed the value contained in the
--   <a>Just</a>. Results are discarded.
--   
--   Taken from <a>whileJust_</a>.
whileJust_ :: Monad m => m (Maybe a) -> (a -> m b) -> m ()

-- | Defined as 'work = whileJust_ highestPriorityUnstableNode (uncurry
--   recompute)'.
--   
--   Tries to dequeue the <a>highestPriorityUnstableNode</a> and
--   <a>recompute</a>s the value of one of its <a>unstable</a> points,
--   until the worklist is empty, indicating that a fixed-point has been
--   reached.
work :: GraphRef graph => Datafixable (DependencyM graph domain) => ReaderT (Env graph domain) IO ()

-- | Computes a solution to the described <a>DataFlowProblem</a> by
--   iterating <a>TransferFunction</a>s until a fixed-point is reached.
--   
--   It does do by employing a worklist algorithm, iterating unstable
--   <a>Node</a>s only. <a>Node</a>s become unstable when the point of
--   another <a>Node</a> their <a>TransferFunction</a> <a>dependOn</a>ed
--   changed.
--   
--   The sole initially unstable <a>Node</a> is the last parameter, and if
--   your <tt>domain</tt> is function-valued (so the returned <a>Arrows</a>
--   expands to a function), then any further parameters specify the exact
--   point in the <a>Node</a>s transfer function you are interested in.
fixProblem :: forall domain graph. GraphRef graph => Datafixable (DependencyM graph domain) => DataFlowProblem (DependencyM graph domain) -> Density graph -> IterationBound domain -> Node -> Arrows (ParamTypes domain) (ReturnType domain)
instance GHC.Base.Monad (Datafix.Worklist.Internal.DependencyM graph domain)
instance GHC.Base.Applicative (Datafix.Worklist.Internal.DependencyM graph domain)
instance GHC.Base.Functor (Datafix.Worklist.Internal.DependencyM graph domain)
instance (Datafix.Worklist.Internal.Datafixable (Datafix.Worklist.Internal.DependencyM graph domain), Datafix.Worklist.Graph.GraphRef graph) => Datafix.Description.MonadDependency (Datafix.Worklist.Internal.DependencyM graph domain)


-- | This module provides the <a>fixProblem</a> function, which solves the
--   description of a <a>DataFlowProblem</a> by employing a worklist
--   algorithm.
module Datafix.Worklist

-- | The concrete <a>MonadDependency</a> for this worklist-based solver.
--   
--   This essentially tracks the current approximation of the solution to
--   the <a>DataFlowProblem</a> as mutable state while <a>fixProblem</a>
--   makes sure we will eventually halt with a conservative approximation.
data DependencyM graph domain a

-- | A constraint synonym for the constraints <tt>m</tt> and its associated
--   <a>Domain</a> have to suffice.
--   
--   This is actually a lot less scary than you might think. Assuming we
--   got <a>quantified class constraints</a>, <tt>Datafixable</tt> is a
--   specialized version of this:
--   
--   <pre>
--   type Datafixable m =
--     ( forall r. Currying (ParamTypes (Domain m)) r
--     , MonoMapKey (Products (ParamTypes (Domain m)))
--     , BoundedJoinSemiLattice (ReturnType (Domain m))
--     )
--   </pre>
--   
--   Now, let's assume a concrete <tt>Domain m ~ String -&gt; Bool -&gt;
--   Int</tt>, so that <tt><a>ParamTypes</a> (String -&gt; Bool -&gt;
--   Int)</tt> expands to the type-level list <tt>'[String, Bool]</tt> and
--   <tt><a>Products</a> '[String, Bool]</tt> reduces to <tt>(String,
--   Bool)</tt>.
--   
--   Then this constraint makes sure we are able to
--   
--   <ol>
--   <li>Curry the domain of <tt>String -&gt; Bool -&gt; r</tt> for all
--   <tt>r</tt> to e.g. <tt>(String, Bool) -&gt; r</tt>. See
--   <a>Currying</a>. This constraint should always be discharged
--   automatically by the type-checker as soon as <a>ParamTypes</a> and
--   <tt>ReturnTypes</tt> reduce for the <a>Domain</a> argument, which
--   happens when the concrete <tt><a>MonadDependency</a> m</tt> is
--   known.(Actually, we do this for multiple concrete <tt>r</tt> because
--   of the missing support for quantified class constraints)</li>
--   <li>We want to use a <a>monotone</a> map of <tt>(String, Bool)</tt> to
--   <tt>Int</tt> (the <tt>ReturnType (Domain m)</tt>). This is ensured by
--   the <tt><a>MonoMapKey</a> (String, Bool)</tt> constraint.This
--   constraint has to be discharged manually, but should amount to a
--   single line of boiler-plate in most cases, see <a>MonoMapKey</a>.Note
--   that the monotonicity requirement means we have to pull non-monotone
--   arguments in <tt>Domain m</tt> into the <a>Node</a> portion of the
--   <a>DataFlowProblem</a>.</li>
--   <li>For fixed-point iteration to work at all, the values which we
--   iterate naturally have to be instances of
--   <a>BoundedJoinSemiLattice</a>. That type-class allows us to start
--   iteration from a most-optimistic <a>bottom</a> value and successively
--   iterate towards a conservative approximation using the '(/)'
--   operator.</li>
--   </ol>
type Datafixable m = (Currying (ParamTypes (Domain m)) (ReturnType (Domain m)), Currying (ParamTypes (Domain m)) (m (ReturnType (Domain m))), Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m) -> Bool), Currying (ParamTypes (Domain m)) (ReturnType (Domain m) -> ReturnType (Domain m)), MonoMapKey (Products (ParamTypes (Domain m))), BoundedJoinSemiLattice (ReturnType (Domain m)))

-- | Specifies the <i>density</i> of the problem, e.g. whether the domain
--   of <a>Node</a>s can be confined to a finite range, in which case
--   <a>fixProblem</a> tries to use a <a>Data.Vector</a> based graph
--   representation rather than one based on <a>Data.IntMap</a>.
data Density graph
[Sparse] :: Density Ref
[Dense] :: Node -> Density Ref

-- | Expresses that iteration should or shouldn't stop after a point has
--   been iterated a finite number of times.
data IterationBound domain

-- | Will keep on iterating until a precise, yet conservative approximation
--   has been reached. Make sure that your <tt>domain</tt> satisfies the
--   <a>ascending chain condition</a>, e.g. that fixed-point iteration
--   always comes to a halt!
NeverAbort :: IterationBound domain

-- | For when your <tt>domain</tt> doesn't satisfy the ascending chain
--   condition or when you are sensitive about solution performance.
--   
--   The <a>Int</a>eger determines the maximum number of iterations of a
--   single point of a <a>Node</a> (with which an entire function with many
--   points may be associated) before iteration aborts in that point by
--   calling the supplied <a>AbortionFunction</a>. The responsibility of
--   the <a>AbortionFunction</a> is to find a sufficiently conservative
--   approximation for the current value at that point.
--   
--   When your <a>ReturnType</a> is an instance of
--   <a>BoundedMeetSemiLattice</a>, <a>abortWithTop</a> might be a
--   worthwhile option. A more sophisticated solution would trim the
--   current value to a certain cut-off depth, depending on the first
--   parameter, instead.
AbortAfter :: Int -> (AbortionFunction domain) -> IterationBound domain

-- | Computes a solution to the described <a>DataFlowProblem</a> by
--   iterating <a>TransferFunction</a>s until a fixed-point is reached.
--   
--   It does do by employing a worklist algorithm, iterating unstable
--   <a>Node</a>s only. <a>Node</a>s become unstable when the point of
--   another <a>Node</a> their <a>TransferFunction</a> <a>dependOn</a>ed
--   changed.
--   
--   The sole initially unstable <a>Node</a> is the last parameter, and if
--   your <tt>domain</tt> is function-valued (so the returned <a>Arrows</a>
--   expands to a function), then any further parameters specify the exact
--   point in the <a>Node</a>s transfer function you are interested in.
fixProblem :: forall domain graph. GraphRef graph => Datafixable (DependencyM graph domain) => DataFlowProblem (DependencyM graph domain) -> Density graph -> IterationBound domain -> Node -> Arrows (ParamTypes domain) (ReturnType domain)


-- | This is the top-level, import-all, kitchen sink module.
--   
--   Look at <a>Datafix.Tutorial</a> for a tour guided by use cases.
module Datafix


-- | <h1>What is This?</h1>
--   
--   The purpose of <tt>datafix</tt> is to separate declaring <a>data-flow
--   problems</a> from computing their solutions by <a>fixed-point
--   iteration</a>.
--   
--   The motivation for this library arose when I was combining two
--   analyses within GHC for my master's thesis. I recently <a>held a
--   talk</a> on that topic, feel free to click through if you want to know
--   the details.
--   
--   You can think of data-flow problems as problems that are solvable by
--   <a>dynamic programming</a> or <a>memoization</a>, except that the
--   dependency graph of data-flow problems doesn't need to be acyclic.
--   
--   Data-flow problems are declared with the primitives in
--   <tt><a>Datafix.Description</a></tt> and solved by
--   <tt>Datafix.Worklist.<a>fixProblem</a></tt>.
--   
--   With that out of the way, let's set in place the GHCi environment of
--   our examples:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XScopedTypeVariables
--   
--   &gt;&gt;&gt; :set -XTypeFamilies
--   
--   &gt;&gt;&gt; import Datafix
--   
--   &gt;&gt;&gt; import Data.Proxy (Proxy (..))
--   
--   &gt;&gt;&gt; import Algebra.Lattice (JoinSemiLattice (..), BoundedJoinSemiLattice (..))
--   
--   &gt;&gt;&gt; import Numeric.Natural
--   </pre>
--   
--   <h1>Use Case: Solving Recurrences</h1>
--   
--   Let's start out by computing the fibonacci series:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib :: Natural -&gt; Natural
--     fib 0 = 0
--     fib 1 = 1
--     fib n = fib (n-1) + fib (n-2)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fib 3
--   2
--   
--   &gt;&gt;&gt; fib 10
--   55
--   </pre>
--   
--   Bring your rabbits to the vet while you can still count them...
--   
--   Anyway, the fibonacci series is a typical problem exhibiting
--   <i>overlapping subproblems</i>. As a result, our <tt>fib</tt> function
--   from above scales badly in the size of its input argument <tt>n</tt>.
--   Because we repeatedly recompute solutions, the time complexity of our
--   above function is in &lt;math&gt;!
--   
--   We can do better by using <i>dynamic programming</i> or
--   <i>memoization</i> to keep a cache of already computed sub-problems,
--   which helps computing the &lt;math&gt;th item in &lt;math&gt; time and
--   space:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fib2 :: Natural -&gt; Natural
--     fib2 n = fibs !! fromIntegral n
--       where
--         fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fib2 3
--   2
--   
--   &gt;&gt;&gt; fib2 10
--   55
--   </pre>
--   
--   That's one of Haskell's pet issues: Expressing dynamic programs as
--   lists through laziness.
--   
--   As promised in the previous section, we can do the same using
--   <tt>datafix</tt>. First, we need to declare a <a>TransferFunction</a>
--   that makes the data dependencies for the recursive case explicit, as
--   if we were using <a>fix</a> to eliminate the recursion:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferFib
--       :: (MonadDependency m, Domain m ~ Natural)
--       =&gt; Proxy m
--       -&gt; Node
--       -&gt; TransferFunction m Natural
--     transferFib _ (Node 0) = return 0
--     transferFib _ (Node 1) = return 1
--     transferFib p (Node n) = do
--       a &lt;- dependOn p (Node (n-1))
--       b &lt;- dependOn p (Node (n-2))
--       return (a + b)
--   :}
--   </pre>
--   
--   <a>MonadDependency</a> contains a single impure primitive
--   <a>dependOn</a> for that purpose.
--   
--   Every point of the fibonacci series is modeled as a seperate
--   <a>Node</a> of the data-flow graph. By looking at the definition of
--   <a>TransferFunction</a>, we can see that <tt>TransferFunction m
--   Natural ~ m Natural</tt>, so for our simple <tt>Natural</tt>
--   <a>Domain</a>, the transfer function is specified directly in
--   <a>MonadDependency</a>.
--   
--   Note that indeed we eliminated explicit recursion in
--   <tt>transferFib</tt>. This allows the solution algorithm to track and
--   discover dependencies of the transfer function as it is executed!
--   
--   With our transfer function (which denotes data-flow nodes in the
--   semantics of <tt>Natural</tt>s) in place, we can construct a
--   <a>DataFlowProblem</a>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fibDfp :: forall m . (MonadDependency m, Domain m ~ Natural) =&gt; DataFlowProblem m
--     fibDfp = DFP (transferFib (Proxy :: Proxy m)) (const (eqChangeDetector (Proxy :: Proxy m)))
--   :}
--   </pre>
--   
--   The <a>eqChangeDetector</a> is important for cyclic dependency graphs
--   and makes sure we detect when a fixed-point has been reached.
--   
--   That's it for describing the data-flow problem of fibonacci numbers.
--   We can ask <tt>Datafix.Worklist.<a>fixProblem</a></tt> for a solution
--   in a minute.
--   
--   The <a>fixProblem</a> solver demands an instance of
--   <tt>BoundedJoinSemiLattice</tt> on the <a>Domain</a> for when the
--   data-flow graph is cyclic. We conveniently delegate to the total
--   <tt>Ord</tt> instance for <a>Natural</a>, knowing that its semantic
--   interpretation is irrelevant to us:
--   
--   <pre>
--   &gt;&gt;&gt; instance JoinSemiLattice Natural where (\/) = max
--   
--   &gt;&gt;&gt; instance BoundedJoinSemiLattice Natural where bottom = 0
--   </pre>
--   
--   And now the final incantation of the solver:
--   
--   <pre>
--   &gt;&gt;&gt; fixProblem fibDfp Sparse NeverAbort (Node 10)
--   55
--   </pre>
--   
--   This will also execute in &lt;math&gt; space and time, all without
--   worrying about a smart solution strategy involving how to tie knots or
--   allocate vectors. Granted, this doesn't really pay off for simple
--   problems like computing fibonacci numbers because of the boilerplate
--   involved and the somewhat devious type-level story, but the intended
--   use case is that of static analysis of programming languages.
--   
--   Before I delegate you to a blog post about strictness analysis, we
--   will look at a more devious reccurence relation with actual cycles in
--   the resulting data-flow graph.
--   
--   <h1>Use Case: Solving Cyclic Recurrences</h1>
--   
--   The recurrence relation describing fibonacci numbers admits a clear
--   plan of how to compute a solution, because the dependency graph is
--   obviously acyclic: To compute the next new value of the sequence, only
--   the prior two values are needed.
--   
--   This is not true of the following reccurence relation:
--   
--   &lt;math&gt;
--   
--   The identity function is the only solution to this, but it is unclear
--   how we could arrive at that conclusion just by translating that
--   relation into Haskell:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   f n
--     | even n = 2 * f (n `div` 2)
--     | odd n  = f (n + 1) - 1
--   :}
--   </pre>
--   
--   Imagine a call <tt>f 1</tt>: This will call <tt>f 2</tt> recursively,
--   which again will call <tt>f 1</tt>. We hit a cyclic dependency!
--   
--   Fortunately, we can use <tt>datafix</tt> to compute the solution by
--   fixed-point iteration (which assumes monotonicity of the function to
--   approximate):
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     transferF
--       :: (MonadDependency m, Domain m ~ Int)
--       =&gt; Proxy m
--       -&gt; Node
--       -&gt; TransferFunction m Int
--     transferF p (Node n)
--       | even n = (* 2) &lt;$&gt; dependOn p (Node (n `div` 2))
--       | odd n  = (subtract 1) &lt;$&gt; dependOn p (Node (n + 1))
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     fDfp :: forall m . (MonadDependency m, Domain m ~ Int) =&gt; DataFlowProblem m
--     fDfp = DFP (transferF (Proxy :: Proxy m)) (const (eqChangeDetector (Proxy :: Proxy m)))
--   :}
--   </pre>
--   
--   Specification of the data-flow problem works the same as for the
--   <tt>fib</tt> function.
--   
--   As for <tt>Natural</tt>, we need an instance of
--   <tt>BoundedJoinSemiLattice</tt> for <a>Int</a> to compute a solution:
--   
--   <pre>
--   &gt;&gt;&gt; instance JoinSemiLattice Int where (\/) = max
--   
--   &gt;&gt;&gt; instance BoundedJoinSemiLattice Int where bottom = minBound
--   </pre>
--   
--   Now it's just a matter of calling <a>fixProblem</a> with the right
--   parameters:
--   
--   <pre>
--   &gt;&gt;&gt; fixProblem fDfp Sparse NeverAbort (Node 0)
--   0
--   
--   &gt;&gt;&gt; fixProblem fDfp Sparse NeverAbort (Node 5)
--   5
--   
--   &gt;&gt;&gt; fixProblem fDfp Sparse NeverAbort (Node 42)
--   42
--   
--   &gt;&gt;&gt; fixProblem fDfp Sparse NeverAbort (Node (-10))
--   -10
--   </pre>
--   
--   Note how the <i>specification</i> of the data-flow problem was as
--   unexciting as it was for the fibonacci sequence (modulo boilerplate),
--   yet the recurrence we solved was pretty complicated already.
--   
--   Of course, encoding the identity function this way is inefficient. But
--   keep in mind that in general, we don't know the solution to a
--   particular recurrence! It's always possible to solve the recurrence by
--   hand upfront, but that's trading precious developer time for what
--   might be a throw-away problem anyway.
--   
--   Which brings us to the prime and final use case...
--   
--   <h1>Use Case: Static Analysis</h1>
--   
--   Recurrence equations occur <i>all the time</i> in denotational
--   semantics and static data-flow analysis.
--   
--   For every invocation of the compiler, for every module, for every
--   analysis within the compiler, a recurrence relation representing
--   program semantics is to be solved. Naturally, we can't task a human
--   with solving a buch of complicated recurrences everytime we hit
--   compile.
--   
--   In the imperative world, it's common-place to have some kind of
--   fixed-point iteration framework carry out the iteration of the
--   data-flow graph, but I could not find a similar abstraction for
--   functional programming languages yet. Analyses for functional
--   languages are typically carried out as iterated traversals of the
--   syntax tree, but that is unsatisfying for a number of reasons:
--   
--   <ol>
--   <li>Solution logic of the data-flow problem is intertwined with its
--   specification.</li>
--   <li>Solution logic is duplicated among multiple analyses, violating
--   DRY.</li>
--   <li>A consequence of the last two points is that performance tweaks
--   have to be adapted for every analysis separately. In the case of GHC's
--   Demand Analyser, going from chaotic iteration (which corresponds to
--   naive iterated tree traversals) to an iteration scheme that caches
--   results of inner let-bindings, annotations to the syntax tree are
--   suddenly used like <tt>State</tt> threads, which makes the analysis
--   logic even more complex than it already was.</li>
--   </ol>
--   
--   So, I can only encourage any compiler dev who wants to integrate
--   static analyses into their compiler to properly specify the data-flow
--   problems in terms of <tt>datafix</tt> and leave the intricacies of
--   finding a good iteration order to this library :)
--   
--   For a principled approach of how to do that, read this blog post on
--   the matter TODO, where I discuss how to do a simple strictness
--   analysis on GHC Core.
module Datafix.Tutorial
