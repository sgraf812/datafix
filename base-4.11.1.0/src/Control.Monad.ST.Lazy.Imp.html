<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Unsafe #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE MagicHash, UnboxedTuples, RankNTypes #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# OPTIONS_HADDOCK hide #-}</span><span>
</span><a name="line-5"></a><span>
</span><a name="line-6"></a><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><a name="line-7"></a><span class="hs-comment">-- |</span><span>
</span><a name="line-8"></a><span class="hs-comment">-- Module      :  Control.Monad.ST.Lazy.Imp</span><span>
</span><a name="line-9"></a><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2001</span><span>
</span><a name="line-10"></a><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span><span>
</span><a name="line-11"></a><span class="hs-comment">-- </span><span>
</span><a name="line-12"></a><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><a name="line-13"></a><span class="hs-comment">-- Stability   :  provisional</span><span>
</span><a name="line-14"></a><span class="hs-comment">-- Portability :  non-portable (requires universal quantification for runST)</span><span>
</span><a name="line-15"></a><span class="hs-comment">--</span><span>
</span><a name="line-16"></a><span class="hs-comment">-- This module presents an identical interface to &quot;Control.Monad.ST&quot;,</span><span>
</span><a name="line-17"></a><span class="hs-comment">-- except that the monad delays evaluation of state operations until</span><span>
</span><a name="line-18"></a><span class="hs-comment">-- a value depending on them is required.</span><span>
</span><a name="line-19"></a><span class="hs-comment">--</span><span>
</span><a name="line-20"></a><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><a name="line-21"></a><span>
</span><a name="line-22"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Monad.ST.Lazy.Imp</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-23"></a><span>        </span><span class="hs-comment">-- * The 'ST' monad</span><span>
</span><a name="line-24"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span class="hs-special">,</span><span>
</span><a name="line-25"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#runST"><span class="hs-identifier hs-var">runST</span></a><span class="hs-special">,</span><span>
</span><a name="line-26"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier hs-var">fixST</span></a><span class="hs-special">,</span><span>
</span><a name="line-27"></a><span>
</span><a name="line-28"></a><span>        </span><span class="hs-comment">-- * Converting between strict and lazy 'ST'</span><span>
</span><a name="line-29"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var">strictToLazyST</span></a><span class="hs-special">,</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var">lazyToStrictST</span></a><span class="hs-special">,</span><span>
</span><a name="line-30"></a><span>
</span><a name="line-31"></a><span>        </span><span class="hs-comment">-- * Converting 'ST' To 'IO'</span><span>
</span><a name="line-32"></a><span>        </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Prim.html#RealWorld"><span class="hs-identifier hs-type">RealWorld</span></a><span class="hs-special">,</span><span>
</span><a name="line-33"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#stToIO"><span class="hs-identifier hs-var">stToIO</span></a><span class="hs-special">,</span><span>
</span><a name="line-34"></a><span>
</span><a name="line-35"></a><span>        </span><span class="hs-comment">-- * Unsafe operations</span><span>
</span><a name="line-36"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#unsafeInterleaveST"><span class="hs-identifier hs-var">unsafeInterleaveST</span></a><span class="hs-special">,</span><span>
</span><a name="line-37"></a><span>        </span><a href="Control.Monad.ST.Lazy.Imp.html#unsafeIOToST"><span class="hs-identifier hs-var">unsafeIOToST</span></a><span>
</span><a name="line-38"></a><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-39"></a><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span> </span><a href="Control.Monad.Fix.html"><span class="hs-identifier">Control.Monad.Fix</span></a><span>
</span><a name="line-41"></a><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Control.Monad.ST.html"><span class="hs-identifier">Control.Monad.ST</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">ST</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Control.Monad.ST.Unsafe.html"><span class="hs-identifier">Control.Monad.ST.Unsafe</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">ST</span><span>
</span><a name="line-44"></a><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="GHC.ST.html"><span class="hs-identifier">GHC.ST</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">GHC.ST</span><span>
</span><a name="line-46"></a><span class="hs-keyword">import</span><span> </span><a href="GHC.Base.html"><span class="hs-identifier">GHC.Base</span></a><span>
</span><a name="line-47"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Control.Monad.Fail.html"><span class="hs-identifier">Control.Monad.Fail</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">Fail</span><span>
</span><a name="line-48"></a><span>
</span><a name="line-49"></a><span class="hs-comment">-- | The lazy state-transformer monad.</span><span>
</span><a name="line-50"></a><span class="hs-comment">-- A computation of type @'ST' s a@ transforms an internal state indexed</span><span>
</span><a name="line-51"></a><span class="hs-comment">-- by @s@, and returns a value of type @a@.</span><span>
</span><a name="line-52"></a><span class="hs-comment">-- The @s@ parameter is either</span><span>
</span><a name="line-53"></a><span class="hs-comment">--</span><span>
</span><a name="line-54"></a><span class="hs-comment">-- * an uninstantiated type variable (inside invocations of 'runST'), or</span><span>
</span><a name="line-55"></a><span class="hs-comment">--</span><span>
</span><a name="line-56"></a><span class="hs-comment">-- * 'RealWorld' (inside invocations of 'stToIO').</span><span>
</span><a name="line-57"></a><span class="hs-comment">--</span><span>
</span><a name="line-58"></a><span class="hs-comment">-- It serves to keep the internal states of different invocations of</span><span>
</span><a name="line-59"></a><span class="hs-comment">-- 'runST' separate from each other and from invocations of 'stToIO'.</span><span>
</span><a name="line-60"></a><span class="hs-comment">--</span><span>
</span><a name="line-61"></a><span class="hs-comment">-- The '&gt;&gt;=' and '&gt;&gt;' operations are not strict in the state.  For example,</span><span>
</span><a name="line-62"></a><span class="hs-comment">--</span><span>
</span><a name="line-63"></a><span class="hs-comment">-- @'runST' (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2@</span><span>
</span><a name="line-64"></a><span class="hs-keyword">newtype</span><span> </span><a name="ST"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier">ST</span></a></a><span> </span><a name="local-6989586621679335944"><a href="#local-6989586621679335944"><span class="hs-identifier">s</span></a></a><span> </span><a name="local-6989586621679335945"><a href="#local-6989586621679335945"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="ST"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier">ST</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="unST"><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier">unST</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier hs-type">State</span></a><span> </span><a href="#local-6989586621679335944"><span class="hs-identifier hs-type">s</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335945"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">,</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier hs-type">State</span></a><span> </span><a href="#local-6989586621679335944"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-65"></a><span>
</span><a name="line-66"></a><span class="hs-comment">-- A lifted state token. This can be imagined as a moment in the timeline</span><span>
</span><a name="line-67"></a><span class="hs-comment">-- of a lazy state thread. Forcing the token forces all delayed actions in</span><span>
</span><a name="line-68"></a><span class="hs-comment">-- the thread up until that moment to be performed.</span><span>
</span><a name="line-69"></a><span class="hs-keyword">data</span><span> </span><a name="State"><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier">State</span></a></a><span> </span><a name="local-6989586621679335943"><a href="#local-6989586621679335943"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="S%23"><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier">S#</span></a></a><span> </span><span class="hs-special">(</span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Prim.html#State%23"><span class="hs-identifier hs-type">State#</span></a><span> </span><a href="#local-6989586621679335943"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span>
</span><a name="line-70"></a><span>
</span><a name="line-71"></a><span class="hs-comment">{- Note [Lazy ST and multithreading]

We used to imagine that passing a polymorphic state token was all that we
needed to keep state threads separate (see Launchbury and Peyton Jones, 1994:
https://www.microsoft.com/en-us/research/publication/lazy-functional-state-threads/).
But this breaks down in the face of concurrency (see #11760). Whereas a strict
ST computation runs to completion before producing anything, a value produced
by running a lazy ST computation may contain a thunk that, when forced, will
lead to further stateful computations. If such a thunk is entered by more than
one thread, then they may both read from and write to the same references and
arrays, interfering with each other. To work around this, any time we lazily
suspend execution of a lazy ST computation, we bind the result pair to a
NOINLINE binding (ensuring that it is not duplicated) and calculate that
pair using (unsafePerformIO . evaluate), ensuring that only one thread will
enter the thunk. We still use lifted state tokens to actually drive execution,
so in these cases we effectively deal with *two* state tokens: the lifted
one we get from the previous computation, and the unlifted one we pull out of
thin air. -}</span><span>
</span><a name="line-89"></a><span>
</span><a name="line-90"></a><span class="hs-comment">{- Note [Lazy ST: not producing lazy pairs]

The fixST and strictToLazyST functions used to construct functions that
produced lazy pairs. Why don't we need that laziness? The ST type is kept
abstract, so no one outside this module can ever get their hands on a (result,
State s) pair. We ourselves never match on such pairs when performing ST
computations unless we also force one of their components. So no one should be
able to detect the change. By refraining from producing such thunks (which
reference delayed ST computations), we avoid having to ask whether we have to
wrap them up with unsafePerformIO. See Note [Lazy ST and multithreading]. -}</span><span>
</span><a name="line-100"></a><span>
</span><a name="line-101"></a><span class="hs-comment">-- | This is a terrible hack to prevent a thunk from being entered twice.</span><span>
</span><a name="line-102"></a><span class="hs-comment">-- Simon Peyton Jones would very much like to be rid of it.</span><span>
</span><a name="line-103"></a><span class="hs-identifier">noDup</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679336014"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679336014"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-104"></a><a name="noDup"><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier">noDup</span></a></a><span> </span><a name="local-6989586621679336015"><a href="#local-6989586621679336015"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Magic.html#runRW%23"><span class="hs-identifier hs-var">runRW#</span></a><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679336016"><a href="#local-6989586621679336016"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-105"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Prim.html#noDuplicate%23"><span class="hs-identifier hs-var">noDuplicate#</span></a><span> </span><a href="#local-6989586621679336016"><span class="hs-identifier hs-var">s</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-106"></a><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679336015"><span class="hs-identifier hs-var">a</span></a><span class="hs-special">)</span><span>
</span><a name="line-107"></a><span>
</span><a name="line-108"></a><span class="hs-comment">-- | @since 2.01</span><span>
</span><a name="line-109"></a><span class="hs-keyword">instance</span><span> </span><a href="GHC.Base.html#Functor"><span class="hs-identifier hs-type">Functor</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679335990"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-110"></a><span>    </span><a name="local-3458764513820541101"><a href="GHC.Base.html#fmap"><span class="hs-identifier">fmap</span></a></a><span> </span><a name="local-6989586621679335991"><a href="#local-6989586621679335991"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679335992"><a href="#local-6989586621679335992"><span class="hs-identifier">m</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335993"><a href="#local-6989586621679335993"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-111"></a><span>      </span><span class="hs-keyword">let</span><span>
</span><a name="line-112"></a><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-113"></a><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-114"></a><span>        </span><a name="local-6989586621679335994"><a href="#local-6989586621679335994"><span class="hs-identifier">res</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335992"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335993"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span>
</span><a name="line-115"></a><span>        </span><span class="hs-special">(</span><a name="local-6989586621679335995"><a href="#local-6989586621679335995"><span class="hs-identifier">r</span></a></a><span class="hs-special">,</span><a name="local-6989586621679335996"><a href="#local-6989586621679335996"><span class="hs-identifier">new_s</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335994"><span class="hs-identifier hs-var">res</span></a><span>
</span><a name="line-116"></a><span>      </span><span class="hs-keyword">in</span><span>
</span><a name="line-117"></a><span>        </span><span class="hs-special">(</span><a href="#local-6989586621679335991"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679335995"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">,</span><a href="#local-6989586621679335996"><span class="hs-identifier hs-var">new_s</span></a><span class="hs-special">)</span><span>
</span><a name="line-118"></a><span>
</span><a name="line-119"></a><span>    </span><a name="local-6989586621679335997"><a href="#local-6989586621679335997"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-8214565720323792765"><a href="GHC.Base.html#%3C%24"><span class="hs-operator">&lt;$</span></a></a><span> </span><a name="local-6989586621679335998"><a href="#local-6989586621679335998"><span class="hs-identifier">m</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335999"><a href="#local-6989586621679335999"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-120"></a><span>      </span><span class="hs-keyword">let</span><span>
</span><a name="line-121"></a><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">s'</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-122"></a><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-123"></a><span>        </span><a name="local-6989586621679336000"><a href="#local-6989586621679336000"><span class="hs-identifier">s'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335998"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335999"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-124"></a><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335997"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679336000"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">)</span><span>
</span><a name="line-125"></a><span>
</span><a name="line-126"></a><span class="hs-comment">-- | @since 2.01</span><span>
</span><a name="line-127"></a><span class="hs-keyword">instance</span><span> </span><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679335957"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-128"></a><span>    </span><a name="local-3458764513820541680"><a href="GHC.Base.html#pure"><span class="hs-identifier">pure</span></a></a><span> </span><a name="local-6989586621679335958"><a href="#local-6989586621679335958"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335959"><a href="#local-6989586621679335959"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335958"><span class="hs-identifier hs-var">a</span></a><span class="hs-special">,</span><a href="#local-6989586621679335959"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span>
</span><a name="line-129"></a><span>
</span><a name="line-130"></a><span>    </span><a name="local-6989586621679335960"><a href="#local-6989586621679335960"><span class="hs-identifier">fm</span></a></a><span> </span><a name="local-3458764513820541679"><a href="GHC.Base.html#%3C%2A%3E"><span class="hs-operator">&lt;*&gt;</span></a></a><span> </span><a name="local-6989586621679335961"><a href="#local-6989586621679335961"><span class="hs-identifier">xm</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335962"><a href="#local-6989586621679335962"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-131"></a><span>       </span><span class="hs-keyword">let</span><span>
</span><a name="line-132"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res1</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-133"></a><span>         </span><span class="hs-glyph">!</span><a name="local-6989586621679335963"><a href="#local-6989586621679335963"><span class="hs-identifier">res1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335960"><span class="hs-identifier hs-var">fm</span></a><span> </span><a href="#local-6989586621679335962"><span class="hs-identifier hs-var">s</span></a><span>
</span><a name="line-134"></a><span>         </span><span class="hs-glyph">!</span><span class="hs-special">(</span><a name="local-6989586621679335964"><a href="#local-6989586621679335964"><span class="hs-identifier">f</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679335965"><a href="#local-6989586621679335965"><span class="hs-identifier">s'</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335963"><span class="hs-identifier hs-var">res1</span></a><span>
</span><a name="line-135"></a><span>
</span><a name="line-136"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res2</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-137"></a><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-138"></a><span>         </span><a name="local-6989586621679335966"><a href="#local-6989586621679335966"><span class="hs-identifier">res2</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335961"><span class="hs-identifier hs-var">xm</span></a><span> </span><a href="#local-6989586621679335965"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">)</span><span>
</span><a name="line-139"></a><span>         </span><span class="hs-special">(</span><a name="local-6989586621679335967"><a href="#local-6989586621679335967"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679335968"><a href="#local-6989586621679335968"><span class="hs-identifier">s''</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335966"><span class="hs-identifier hs-var">res2</span></a><span>
</span><a name="line-140"></a><span>       </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335964"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679335967"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679335968"><span class="hs-identifier hs-var">s''</span></a><span class="hs-special">)</span><span>
</span><a name="line-141"></a><span>    </span><span class="hs-comment">-- Why can we use a strict binding for res1? If someone</span><span>
</span><a name="line-142"></a><span>    </span><span class="hs-comment">-- forces the (f x, s'') pair, then they must need</span><span>
</span><a name="line-143"></a><span>    </span><span class="hs-comment">-- f or s''. To get s'', they need s'.</span><span>
</span><a name="line-144"></a><span>
</span><a name="line-145"></a><span>    </span><a name="local-8214565720323792763"><a href="GHC.Base.html#liftA2"><span class="hs-identifier">liftA2</span></a></a><span> </span><a name="local-6989586621679335969"><a href="#local-6989586621679335969"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679335970"><a href="#local-6989586621679335970"><span class="hs-identifier">m</span></a></a><span> </span><a name="local-6989586621679335971"><a href="#local-6989586621679335971"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335972"><a href="#local-6989586621679335972"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-146"></a><span>      </span><span class="hs-keyword">let</span><span>
</span><a name="line-147"></a><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res1</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-148"></a><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-149"></a><span>        </span><a name="local-6989586621679335973"><a href="#local-6989586621679335973"><span class="hs-identifier">res1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335970"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335972"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span>
</span><a name="line-150"></a><span>        </span><span class="hs-special">(</span><a name="local-6989586621679335974"><a href="#local-6989586621679335974"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679335975"><a href="#local-6989586621679335975"><span class="hs-identifier">s'</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335973"><span class="hs-identifier hs-var">res1</span></a><span>
</span><a name="line-151"></a><span>
</span><a name="line-152"></a><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res2</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-153"></a><span>        </span><a name="local-6989586621679335976"><a href="#local-6989586621679335976"><span class="hs-identifier">res2</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335971"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679335975"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">)</span><span>
</span><a name="line-154"></a><span>        </span><span class="hs-special">(</span><a name="local-6989586621679335977"><a href="#local-6989586621679335977"><span class="hs-identifier">y</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679335978"><a href="#local-6989586621679335978"><span class="hs-identifier">s''</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335976"><span class="hs-identifier hs-var">res2</span></a><span>
</span><a name="line-155"></a><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335969"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679335974"><span class="hs-identifier hs-var">x</span></a><span> </span><a href="#local-6989586621679335977"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679335978"><span class="hs-identifier hs-var">s''</span></a><span class="hs-special">)</span><span>
</span><a name="line-156"></a><span>    </span><span class="hs-comment">-- We don't get to be strict in liftA2, but we clear out a</span><span>
</span><a name="line-157"></a><span>    </span><span class="hs-comment">-- NOINLINE in comparison to the default definition, which may</span><span>
</span><a name="line-158"></a><span>    </span><span class="hs-comment">-- help the simplifier.</span><span>
</span><a name="line-159"></a><span>
</span><a name="line-160"></a><span>    </span><a name="local-6989586621679335979"><a href="#local-6989586621679335979"><span class="hs-identifier">m</span></a></a><span> </span><a name="local-3458764513820541681"><a href="GHC.Base.html#%2A%3E"><span class="hs-operator">*&gt;</span></a></a><span> </span><a name="local-6989586621679335980"><a href="#local-6989586621679335980"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679335981"><a href="#local-6989586621679335981"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-161"></a><span>       </span><span class="hs-keyword">let</span><span>
</span><a name="line-162"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">s'</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-163"></a><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-164"></a><span>         </span><a name="local-6989586621679335982"><a href="#local-6989586621679335982"><span class="hs-identifier">s'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335979"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335981"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-165"></a><span>       </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335980"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679335982"><span class="hs-identifier hs-var">s'</span></a><span>
</span><a name="line-166"></a><span>
</span><a name="line-167"></a><span>    </span><a name="local-6989586621679335983"><a href="#local-6989586621679335983"><span class="hs-identifier">m</span></a></a><span> </span><a name="local-8214565720323792764"><a href="GHC.Base.html#%3C%2A"><span class="hs-operator">&lt;*</span></a></a><span> </span><a name="local-6989586621679335984"><a href="#local-6989586621679335984"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679335985"><a href="#local-6989586621679335985"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-168"></a><span>       </span><span class="hs-keyword">let</span><span>
</span><a name="line-169"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res1</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-170"></a><span>         </span><span class="hs-glyph">!</span><a name="local-6989586621679335986"><a href="#local-6989586621679335986"><span class="hs-identifier">res1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335983"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335985"><span class="hs-identifier hs-var">s</span></a><span>
</span><a name="line-171"></a><span>         </span><span class="hs-glyph">!</span><span class="hs-special">(</span><a name="local-6989586621679335987"><a href="#local-6989586621679335987"><span class="hs-identifier">mr</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679335988"><a href="#local-6989586621679335988"><span class="hs-identifier">s'</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335986"><span class="hs-identifier hs-var">res1</span></a><span>
</span><a name="line-172"></a><span>
</span><a name="line-173"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">s''</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-174"></a><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-175"></a><span>         </span><a name="local-6989586621679335989"><a href="#local-6989586621679335989"><span class="hs-identifier">s''</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335984"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679335988"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-176"></a><span>       </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335987"><span class="hs-identifier hs-var">mr</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679335989"><span class="hs-identifier hs-var">s''</span></a><span class="hs-special">)</span><span>
</span><a name="line-177"></a><span>    </span><span class="hs-comment">-- Why can we use a strict binding for res1? The same reason as</span><span>
</span><a name="line-178"></a><span>    </span><span class="hs-comment">-- in &lt;*&gt;. If someone demands the (mr, s'') pair, then they will</span><span>
</span><a name="line-179"></a><span>    </span><span class="hs-comment">-- force mr or s''. To get s'', they need s'.</span><span>
</span><a name="line-180"></a><span>
</span><a name="line-181"></a><span class="hs-comment">-- | @since 2.01</span><span>
</span><a name="line-182"></a><span class="hs-keyword">instance</span><span> </span><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679335949"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-183"></a><span>
</span><a name="line-184"></a><span>    </span><a name="local-3458764513820541098"><a href="GHC.Base.html#fail"><span class="hs-identifier">fail</span></a></a><span> </span><a name="local-6989586621679335950"><a href="#local-6989586621679335950"><span class="hs-identifier">s</span></a></a><span>   </span><span class="hs-glyph">=</span><span> </span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a><span> </span><a href="#local-6989586621679335950"><span class="hs-identifier hs-var">s</span></a><span>
</span><a name="line-185"></a><span>
</span><a name="line-186"></a><span>    </span><span class="hs-special">(</span><a name="local-3458764513820541100"><a href="GHC.Base.html#%3E%3E"><span class="hs-operator">&gt;&gt;</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a href="GHC.Base.html#%2A%3E"><span class="hs-operator hs-var">*&gt;</span></a><span class="hs-special">)</span><span>
</span><a name="line-187"></a><span>
</span><a name="line-188"></a><span>    </span><a name="local-6989586621679335951"><a href="#local-6989586621679335951"><span class="hs-identifier">m</span></a></a><span> </span><a name="local-3458764513820541099"><a href="GHC.Base.html#%3E%3E%3D"><span class="hs-operator">&gt;&gt;=</span></a></a><span> </span><a name="local-6989586621679335952"><a href="#local-6989586621679335952"><span class="hs-identifier">k</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679335953"><a href="#local-6989586621679335953"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-189"></a><span>       </span><span class="hs-keyword">let</span><span>
</span><a name="line-190"></a><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><a name="line-191"></a><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="hs-pragma">res</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><a name="line-192"></a><span>         </span><a name="local-6989586621679335954"><a href="#local-6989586621679335954"><span class="hs-identifier">res</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">unST</span><span> </span><a href="#local-6989586621679335951"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679335953"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span>
</span><a name="line-193"></a><span>         </span><span class="hs-special">(</span><a name="local-6989586621679335955"><a href="#local-6989586621679335955"><span class="hs-identifier">r</span></a></a><span class="hs-special">,</span><a name="local-6989586621679335956"><a href="#local-6989586621679335956"><span class="hs-identifier">new_s</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679335954"><span class="hs-identifier hs-var">res</span></a><span>
</span><a name="line-194"></a><span>       </span><span class="hs-keyword">in</span><span>
</span><a name="line-195"></a><span>         </span><span class="hs-identifier">unST</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679335952"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679335955"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679335956"><span class="hs-identifier hs-var">new_s</span></a><span>
</span><a name="line-196"></a><span>
</span><a name="line-197"></a><span class="hs-comment">-- | @since 4.10</span><span>
</span><a name="line-198"></a><span class="hs-keyword">instance</span><span> </span><a href="Control.Monad.Fail.html#MonadFail"><span class="hs-identifier hs-type">Fail.MonadFail</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679335947"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-199"></a><span>    </span><a name="local-3458764513820541104"><a href="Control.Monad.Fail.html#fail"><span class="hs-identifier">fail</span></a></a><span> </span><a name="local-6989586621679335948"><a href="#local-6989586621679335948"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a><span> </span><a href="#local-6989586621679335948"><span class="hs-identifier hs-var">s</span></a><span>
</span><a name="line-200"></a><span>
</span><a name="line-201"></a><span class="hs-comment">-- | Return the value computed by a state transformer computation.</span><span>
</span><a name="line-202"></a><span class="hs-comment">-- The @forall@ ensures that the internal state used by the 'ST'</span><span>
</span><a name="line-203"></a><span class="hs-comment">-- computation is inaccessible to the rest of the program.</span><span>
</span><a name="line-204"></a><span class="hs-identifier">runST</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><a name="local-6989586621679336013"><a href="#local-6989586621679336013"><span class="hs-identifier">s</span></a></a><span class="hs-operator">.</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336013"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336012"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679336012"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-205"></a><a name="runST"><a href="Control.Monad.ST.Lazy.Imp.html#runST"><span class="hs-identifier">runST</span></a></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a name="local-6989586621679336017"><a href="#local-6989586621679336017"><span class="hs-identifier">st</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Magic.html#runRW%23"><span class="hs-identifier hs-var">runRW#</span></a><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679336018"><a href="#local-6989586621679336018"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679336017"><span class="hs-identifier hs-var">st</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a><span> </span><a href="#local-6989586621679336018"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679336019"><a href="#local-6989586621679336019"><span class="hs-identifier">r</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679336019"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-206"></a><span>
</span><a name="line-207"></a><span class="hs-comment">-- | Allow the result of a state transformer computation to be used (lazily)</span><span>
</span><a name="line-208"></a><span class="hs-comment">-- inside the computation.</span><span>
</span><a name="line-209"></a><span class="hs-comment">-- Note that if @f@ is strict, @'fixST' f = _|_@.</span><span>
</span><a name="line-210"></a><span class="hs-identifier">fixST</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679336010"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336011"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336010"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336011"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336010"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-211"></a><a name="fixST"><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier">fixST</span></a></a><span> </span><a name="local-6989586621679336020"><a href="#local-6989586621679336020"><span class="hs-identifier">m</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679336021"><a href="#local-6989586621679336021"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-212"></a><span>                </span><span class="hs-keyword">let</span><span>
</span><a name="line-213"></a><span>                   </span><a name="local-6989586621679336022"><a href="#local-6989586621679336022"><span class="hs-identifier">q</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><a name="local-6989586621679336023"><a href="#local-6989586621679336023"><span class="hs-identifier">r</span></a></a><span class="hs-special">,</span><a name="local-6989586621679336024"><a href="#local-6989586621679336024"><span class="hs-identifier">_s'</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unST</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679336020"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679336023"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679336021"><span class="hs-identifier hs-var">s</span></a><span>
</span><a name="line-214"></a><span>                </span><span class="hs-keyword">in</span><span> </span><a href="#local-6989586621679336022"><span class="hs-identifier hs-var">q</span></a><span class="hs-special">)</span><span>
</span><a name="line-215"></a><span class="hs-comment">-- Why don't we need unsafePerformIO in fixST? We create a thunk, q,</span><span>
</span><a name="line-216"></a><span class="hs-comment">-- to perform a lazy state computation, and we pass a reference to that</span><span>
</span><a name="line-217"></a><span class="hs-comment">-- thunk, r, to m. Uh oh? No, I think it should be fine, because that thunk</span><span>
</span><a name="line-218"></a><span class="hs-comment">-- itself is demanded directly in the `let` body. See also</span><span>
</span><a name="line-219"></a><span class="hs-comment">-- Note [Lazy ST: not producing lazy pairs].</span><span>
</span><a name="line-220"></a><span>
</span><a name="line-221"></a><span class="hs-comment">-- | @since 2.01</span><span>
</span><a name="line-222"></a><span class="hs-keyword">instance</span><span> </span><a href="Control.Monad.Fix.html#MonadFix"><span class="hs-identifier hs-type">MonadFix</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679335946"><span class="hs-identifier hs-type">s</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-223"></a><span>        </span><a name="local-3458764513820541103"><a href="Control.Monad.Fix.html#mfix"><span class="hs-identifier">mfix</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier hs-var">fixST</span></a><span>
</span><a name="line-224"></a><span>
</span><a name="line-225"></a><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><a name="line-226"></a><span class="hs-comment">-- Strict &lt;--&gt; Lazy</span><span>
</span><a name="line-227"></a><span>
</span><a name="line-228"></a><span class="hs-comment">{-|
Convert a strict 'ST' computation into a lazy one.  The strict state
thread passed to 'strictToLazyST' is not performed until the result of
the lazy state thread it returns is demanded.
-}</span><span>
</span><a name="line-233"></a><span class="hs-identifier">strictToLazyST</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="GHC.ST.html#ST"><span class="hs-identifier hs-type">ST.ST</span></a><span> </span><a href="#local-6989586621679336008"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336009"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336008"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336009"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-234"></a><a name="strictToLazyST"><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier">strictToLazyST</span></a></a><span> </span><span class="hs-special">(</span><a href="GHC.ST.html#ST"><span class="hs-identifier hs-var">GHC.ST.ST</span></a><span> </span><a name="local-6989586621679336025"><a href="#local-6989586621679336025"><span class="hs-identifier">m</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a><span> </span><a name="local-6989586621679336026"><a href="#local-6989586621679336026"><span class="hs-identifier">s</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-235"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679336025"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679336026"><span class="hs-identifier hs-var">s</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-236"></a><span>    </span><span class="hs-special">(#</span><span> </span><a name="local-6989586621679336027"><a href="#local-6989586621679336027"><span class="hs-identifier">s'</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679336028"><a href="#local-6989586621679336028"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679336028"><span class="hs-identifier hs-var">a</span></a><span class="hs-special">,</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a><span> </span><a href="#local-6989586621679336027"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">)</span><span>
</span><a name="line-237"></a><span class="hs-comment">-- See Note [Lazy ST: not producing lazy pairs]</span><span>
</span><a name="line-238"></a><span>
</span><a name="line-239"></a><span class="hs-comment">{-| 
Convert a lazy 'ST' computation into a strict one.
-}</span><span>
</span><a name="line-242"></a><span class="hs-identifier">lazyToStrictST</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336006"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336007"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="GHC.ST.html#ST"><span class="hs-identifier hs-type">ST.ST</span></a><span> </span><a href="#local-6989586621679336006"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336007"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-243"></a><a name="lazyToStrictST"><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier">lazyToStrictST</span></a></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a><span> </span><a name="local-6989586621679336029"><a href="#local-6989586621679336029"><span class="hs-identifier">m</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="GHC.ST.html#ST"><span class="hs-identifier hs-var">GHC.ST.ST</span></a><span> </span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679336030"><a href="#local-6989586621679336030"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-244"></a><span>        </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679336029"><span class="hs-identifier hs-var">m</span></a><span> </span><span class="hs-special">(</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a><span> </span><a href="#local-6989586621679336030"><span class="hs-identifier hs-var">s</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679336031"><a href="#local-6989586621679336031"><span class="hs-identifier">a</span></a></a><span class="hs-special">,</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a><span> </span><a name="local-6989586621679336032"><a href="#local-6989586621679336032"><span class="hs-identifier">s'</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(#</span><span> </span><a href="#local-6989586621679336032"><span class="hs-identifier hs-var">s'</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679336031"><span class="hs-identifier hs-var">a</span></a><span> </span><span class="hs-special">#)</span><span>
</span><a name="line-245"></a><span>
</span><a name="line-246"></a><span class="hs-comment">-- | A monad transformer embedding lazy state transformers in the 'IO'</span><span>
</span><a name="line-247"></a><span class="hs-comment">-- monad.  The 'RealWorld' parameter indicates that the internal state</span><span>
</span><a name="line-248"></a><span class="hs-comment">-- used by the 'ST' computation is a special one supplied by the 'IO'</span><span>
</span><a name="line-249"></a><span class="hs-comment">-- monad, and thus distinct from those used by invocations of 'runST'.</span><span>
</span><a name="line-250"></a><span class="hs-identifier">stToIO</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Prim.html#RealWorld"><span class="hs-identifier hs-type">RealWorld</span></a><span> </span><a href="#local-6989586621679336005"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a><span> </span><a href="#local-6989586621679336005"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-251"></a><a name="stToIO"><a href="Control.Monad.ST.Lazy.Imp.html#stToIO"><span class="hs-identifier">stToIO</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="GHC.IO.html#stToIO"><span class="hs-identifier hs-var">ST.stToIO</span></a><span> </span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var">lazyToStrictST</span></a><span>
</span><a name="line-252"></a><span>
</span><a name="line-253"></a><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><a name="line-254"></a><span class="hs-comment">-- Strict &lt;--&gt; Lazy</span><span>
</span><a name="line-255"></a><span>
</span><a name="line-256"></a><span class="hs-identifier">unsafeInterleaveST</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336003"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336004"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336003"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336004"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-257"></a><a name="unsafeInterleaveST"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeInterleaveST"><span class="hs-identifier">unsafeInterleaveST</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var">strictToLazyST</span></a><span> </span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a><span> </span><a href="GHC.ST.html#unsafeInterleaveST"><span class="hs-identifier hs-var">ST.unsafeInterleaveST</span></a><span> </span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var">lazyToStrictST</span></a><span>
</span><a name="line-258"></a><span>
</span><a name="line-259"></a><span class="hs-identifier">unsafeIOToST</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="../ghc-prim-0.5.2.0/src/%{MODULE/./-}.html#%{NAME}/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a><span> </span><a href="#local-6989586621679336001"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a><span> </span><a href="#local-6989586621679336002"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-6989586621679336001"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-260"></a><a name="unsafeIOToST"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeIOToST"><span class="hs-identifier">unsafeIOToST</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var">strictToLazyST</span></a><span> </span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a><span> </span><a href="GHC.IO.html#unsafeIOToST"><span class="hs-identifier hs-var">ST.unsafeIOToST</span></a><span>
</span><a name="line-261"></a><span>
</span><a name="line-262"></a></pre></body></html>